# 1 为什么要分库分表
业务飞速发展导致了数据规模的急速膨胀，单机数据库已经无法适应互联网业务的发展。

传统的将数据集中存储至单一数据节点的解决方案，在容量、性能、可用性和运维成本这三方面难于满足海量数据场景。在单库单表数据量超过一定容量水位的情况下，索引树层级增加，磁盘 IO 也很可能出现压力，会导致很多问题。

- 性能
由于MySQL采用 B+树索引，数据量超过阈值时，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；高并发访问请求也使得集中式数据库成为系统的最大瓶颈。

- 可用性
服务化的无状态型，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。而单一的数据节点，或者简单的主从架构，已经越来越难以承担。从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。

> 主从复制只能减轻读压力，但容量问题是无法解决的。

# 2 概念辨析
分库和分表是两码事，可能光分库不分表，也可能光分表不分库。
比如业务发展迅猛，注册用户数达到了2000万！每天活跃用户数100万！每天单表数据量10万条！高峰期每秒最大请求达到1000！感觉压力大。
因为每天多10万条数据，一个月就多300万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑1000 QPS也还行。但现在开始担心了，接下来咋整？

此时每天活跃用户数上千万，每天单表新增数据达50万，目前一个表总数据量都已经达到了两三千万了！扛不住！数据库磁盘容量不断消耗！高峰期并发达到5000~8000！你的系统绝对支撑不到现在，已经挂掉了！

所以分库分表实际上是跟着公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。

比如你单表都几千万数据了，你确定你能抗住么？
绝对不行，单表数据量太大，会极大影响你的 SQL执行性能，到了后面你的SQL可能就跑的很慢。经验来看，单表到几百万时性能就会相对差点，就得分表了。

## 分表
把一个表的数据放到多个表中，然后查询时，就查一个表。

比如按用户id分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在200万以内。

## 分库
单库一般达到2000并发，亟需扩容，合适的单库并发值推荐在1000/s。可将一个库的数据拆分到多个库，访问时就访问一个库。

- 分库分表的由来
![](https://img-blog.csdnimg.cn/20190712220954195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)

# 3 分库分表中间件

## cobar
阿里b2b团队开发，proxy层方案，但已停止维护。
- [Github地址](https://github.com/alibaba/cobar/)
![](https://img-blog.csdnimg.cn/20210203103643124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)
不支持读写分离、存储过程、跨库join和分页。

## TDDL
淘宝团队开发，client层方案
- [Github地址](https://github.com/alibaba/tb_tddl)
![](https://img-blog.csdnimg.cn/20190712202411687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)

不支持join、多表查询等语法，支持读写分离。
使用的也不多，因为还依赖淘宝的diamond配置管理系统，而且已被阿里云商用，不再开源。

##  atlas
-  [Github地址](https://github.com/Qihoo360/Atlas)
![](https://img-blog.csdnimg.cn/20210203104038930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)

360开源的，proxy层方案，但六年前就不维护了。

## sharding-jdbc（shardingsphere）
-  [Github地址](https://github.com/apache/incubator-shardingsphere)
![](https://img-blog.csdnimg.cn/20190712204304352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20210203104142767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)最初由当当开源，client层方案。
SQL语法支持较多，支持分库分表、读写分离、分布式id生成、柔性事务（最大努力送达型事务、TCC事务）。被大量公司使用，我司也在用。现在已经升级为Apache组织的项目。

这种client层方案的优点：
不用部署，运维成本低，无需代理层的二次转发请求，性能很高
但遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合sharding-jdbc的依赖。

## mycat
-  [Github地址](https://github.com/MyCATApache/Mycat-Server)
![](https://img-blog.csdnimg.cn/20190712204603810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)
基于cobar改造，proxy层方案，支持的功能非常完善，社区活跃。但相比sharding jdbc年轻一些。

proxy层方案的缺点：
需要部署，自己及运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。


## 总结
综上，sharding-jdbc和mycat可以考虑使用。推荐小型公司选用sharding-jdbc，client层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多。

但中大型公司最好还是选用mycat这类proxy层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护mycat，然后大量项目直接透明使用即可。


# 数据库垂直拆分/水平拆分
- 数据库如何拆分
![](https://img-blog.csdnimg.cn/20190712221229332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70)

## 7.1 水平拆分
把一个表的数据给弄到多个库的多个表里，但每个库的表结构都一样，只不过每个库中表放的数据是不同的，所有库表的数据加起来就是全部数据

### 水平拆分的意义
将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。

## 7.2 垂直拆分
把一个有很多字段的表给拆分成多个表，或者是多个库
每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去
因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

这个其实挺常见的，很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。

还有表层面的拆分，就是分表，将一个表变成N个表，就是让每个表的数据量控制在一定范围内，保证SQL的性能。
否则单表数据量越大，SQL性能就越差。一般是200万行左右，不要太多，但是也得看具体你怎么操作，也可能是500万，或者是100万。你的SQL越复杂，就最好让单表行数越少。

无论是分库还是分表，上面说的那些数据库中间件都可支持。就是基本上那些中间件可以做到你分库分表之后，中间件可以根据你指定的某个字段值，比如说userid，自动路由到对应的库上去，然后再自动路由到对应的表里去。

你就得考虑一下，你的项目里该如何分库分表？
- 垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分
- 水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好
- 分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都ok了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大

# 8  分库分表的方式
## 按range分
就是每个库一段连续的数据，一般按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了

- 好处
后面扩容的时候，就很容易，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了

- 缺点
但是大部分的请求，都是访问最新的数据。实际生产用range，要看场景，你的用户不是仅仅访问最新的数据，而是均匀的访问现在的数据以及历史的数据
## 按某字段hash
均匀分散，最为常用。
- 好处
可以平均分配没给库的数据量和请求压力

- 坏处
扩容起来比较麻烦，会有一个数据迁移的过程

参考
- 《Java工程师面试突击第1季-中华石杉老师》