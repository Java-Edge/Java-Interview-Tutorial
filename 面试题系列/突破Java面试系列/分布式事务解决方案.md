# 1 CAP 定理
##  1.1 概念
CAP 理论在分布式系统中：
- 一致性
分布式环境下**多个节点的数据是否强一致**
- 可用性
分布式**服务能一直保证可用状态**。当用户发出一个请求后，服务能在有限时间内返回结果
- 分区容忍性
特指对网络分区的容忍性

对于共享数据系统，最多只能同时拥有CAP其中的两个，无法三者兼顾。
- 任两者的组合都有其适用场景
- 真实系统应当是ACID与BASE的混合体
- 不同类型的业务可以也应当区别对待
- **分区容忍性是不可或缺的**

![](https://img-blog.csdnimg.cn/20200111011231456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qYXZhZWRnZS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

结论：分布式系统中，最重要的是满足业务需求，而不是追求抽象、绝对的系统特性。

## 2.2 中间件实例
- 优先选择AP，弱化C
Cassandra、Dynamo 等

- 优先选择CP，弱化A
HBase、MongoDB 等

# 2 BASE 理论
## 2.1 核心思想
- 基本可用（BasicallyAvailable）
分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。
- 软状态（SoftState）
允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。
- 最终一致性（EventualConsistency）
分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态

## 2.2 一致性模型
数据的一致性模型可以分类如下：
- 强一致性
数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步实现
- 弱一致性
数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久后可读到
- 最终一致性
弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值

> 分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。

# 3 分布式事务的解决方案
● 异步校对数据
支付宝、微信支付主动查询支付状态、对账单的形式;
● 基于可靠消息(MQ)
异步场景;通用性较强;拓展性较高
● TCC编程式解决方案
严选、阿里、蚂蚁金服自己封装的DTX

## 3.1 实现思路
### 理想状态
像单机数据库事务一样，多个数据库自动通过某种协调机制，实现跨数据库节点的一致性。

- 使用场景
要求严格的一致性，比如金融交易类业务。

### 一般情况
可容忍一段时间的数据不一致，最终通过超时终止，调度补偿等方式，实现数据的最终状态一致性。

- 使用场景
准实时或非实时的处理，比如 T+1 的各类操作，或者电商类操作。

## 3.2 实现方案
### 3.2.1 XA方案
### 3.2.2 TCC方案
#### 三阶段
- Try
对各个服务的资源做检测，对资源进行提前锁定或者预留
- Confirm
在各个服务中执行实际的操作
- Cancel
如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，即执行已操作成功的业务逻辑的回滚操作

## 4.2 跨行转账案例
涉及到两个银行的分布式事务，如果用TCC实现：

- Try阶段
先把两个银行账户中的资金给它冻结住，不让操作
- Confirm阶段
执行实际的转账操作，A银行账户的资金扣减，B银行账户的资金增加
- Cancel阶段
如果任何一个银行的操作执行失败，那么就需要回滚进行补偿
比如A银行账户如果已经扣减了，但是B银行账户资金增加失败了，那么就得把A银行账户资金给加回去。

该方案很少使用，但也有使用场景。
因为这个事务的回滚实际上严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常恶心!

比如说我们，一般来说和钱相关的支付、交易等相关的场景，我们会用TCC，严格严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性!

## 4.3 适用场景
除非你是真的一致性要求太高，是系统中核心之核心的场景!
常见的就是资金类的场景，那可以用TCC方案，自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行补偿/回滚代码。

而且最好是你的各个业务执行的时间都比较短。
但尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，业务代码也很难维护。

## 4.4 方案示意图
![](https://img-blog.csdnimg.cn/20200509153432129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70)
# 5 本地消息表
ebay搞出来的思想。

## 5.1 简介
- A系统在本地一个事务里操作的同时，插入一条数据到消息表
- 接着A系统将这个消息发送到MQ
- B系统接收到消息后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息
- B系统执行成功后，就会更新自己本地消息表的状态以及A系统消息表的状态
- 如果B系统处理失败，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再处理

## 5.2 优点
这个方案保证了**最终一致性**
哪怕B事务失败了，但是A会不断重发消息，直到B那边成功。

## 5.3 缺陷
最大的问题就在于严重依赖于数据库的消息表来管理事务,这个会导致高并发场景无力,难以扩展呢,一般确实很少用
- 本地消息表方案
![](https://img-blog.csdnimg.cn/2019071200124087.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70)

# 6 可靠消息最终一致性方案
不用本地消息表，直接基于MQ实现事务。比如RocketMQ就支持事务消息。

## 6.1 执行流程

1. A系统先发一个prepared消息到MQ，若该prepared消息发送失败，则直接取消操作，不再执行
2. 若该消息发送成功过了，那么接着执行本地事务
	- 如果成功就告诉MQ发送确认消息
	- 如果失败就告诉MQ回滚消息
3. 如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务
4. MQ会自动定时轮询所有prepared消息回调你的接口，问你这个消息是不是本地事务处理失败了，所有没发送确认的消息,是继续重试还是回滚？
这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。
5. 如果系统B的事务失败了咋办？
自动不断重试直到成功，若实在不行，要么针对重要业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；要么发送报警由人工来手工回滚和补偿

使用比较广泛，目前国内互联网公司都采用，直接使用RocketMQ支持的最简单。

## 图解
![](https://img-blog.csdnimg.cn/2019071200164095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70)
# 7 最大努力通知方案

## 7.1 简介
- 系统A本地事务执行完后，发送一个消息到MQ
- 有一专门消费MQ的最大努力通知服务，会消费MQ,然后写入数据库中记录下来，亦可是放入内存队列，接着调用系统B的接口
- 若系统B执行成功就ok；若系统B执行失败，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行才放弃

- 最大努力通知方案示意图![](https://img-blog.csdnimg.cn/20190712120839329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70)
# 8 总结
真的被问到，可以这么说，我们某某特别严格的场景，用的是TCC来保证强一致性；然后其他的一些场景基于了阿里的RocketMQ来实现了分布式事务~

你找一个严格资金要求绝对不能错的场景，你可以说你是用的TCC方案
如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案

> Rocketmq 3.2.6之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，不再赘述

你其实用任何一个分布式事务的这么一个方案，都会导致你那块儿代码会复杂10倍。很多情况下，系统A调用系统B、系统C、系统D，我们可能根本就不做分布式事务。如果调用报错会打印异常日志。

每个月也就那么几个bug，很多bug是功能性的，体验性的，真的是涉及到数据层面的一些bug，一个月就几个，两三个？如果你为了确保系统自动保证数据100%不能错，上了几十个分布式事务，代码太复杂；性能太差，系统吞吐量、性能大幅度下跌。

99%的分布式接口调用，不要做分布式事务，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据。
每个月，每隔几个月，都会对少量的因为代码bug，导致出错的数据，进行人工的修复数据，自己临时动手写个程序，可能要补一些数据，可能要删除一些数据，可能要修改一些字段的值。

比你做50个分布式事务，成本要来的低上百倍，低几十倍

# 权衡
用分布式事务有性能成本，代码也很复杂，开发很长时间，性能和吞吐量下跌，系统更加复杂更加脆弱反而更加容易出bug；好处，如果做好了，TCC、可靠消息最终一致性方案，一定可以100%保证你那快数据不会出错。

像资金、交易、订单这些业务，我们才可用会使用分布式事务方案来保证，会员积分、优惠券、商品信息，其实就不要这么搞了，严重影响性能！


https://developer.ibm.com/zh/articles/j-lo-jta/