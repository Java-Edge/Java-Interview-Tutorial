# 超线程（Hyper-Threading），单指令多数据流（SIMD）技术

- 超标量（Superscalar）技术能够让取指令以及指令译码也并行进行
- 在编译的过程，超长指令字（VLIW）技术可以搞定指令先后的依赖关系，使得一次可以取一个指令包。

超线程（Hyper-Threading），单指令多数据流（SIMD）技术。

## 超线程：Intel多卖给你的那一倍CPU

Pentium 4失败的一个重要原因，就是它的CPU流水线级数太深。早期的Pentium 4流水线深度高达20级，而后期的代号为Prescott的Pentium 4的流水线级数，更是到了31级。超长的流水线，使得之前我们讲的很多解决“冒险”、提升并发的方案都用不上。

因为这些解决“冒险”、提升并发的方案，本质上都是一种指令级并行（Instruction-level parallelism，简称IPL）的技术方案。换句话说就是，CPU想要在同一个时间，去并行地执行两条指令。而这两条指令呢，原本在我们的代码里，是有先后顺序的。无论是我们在流水线里面讲到的流水线架构、分支预测以及乱序执行，还是我们在上一讲说的超标量和超长指令字，都是想要通过同一时间执行两条指令，来提升CPU的吞吐率。

然而在Pentium 4这个CPU上，这些方法都可能因为流水线太深，而起不到效果。我之前讲过，更深的流水线意味着同时在流水线里面的指令就多，相互的依赖关系就多。于是，很多时候我们不得不把流水线停顿下来，插入很多NOP操作，来解决这些依赖带来的“冒险”问题。

不知道是不是因为当时面临的竞争太激烈了，为了让Pentium 4的CPU在性能上更有竞争力一点，2002年底，Intel在的3.06GHz主频的Pentium 4 CPU上，第一次引入了超线程（Hyper-Threading）技术。

什么是超线程技术呢？Intel想，既然CPU同时运行那些在代码层面有前后依赖关系的指令，会遇到各种冒险问题，我们不如去找一些和这些指令完全独立，没有依赖关系的指令来运行好了。那么，这样的指令哪里来呢？自然同时运行在另外一个程序里了。

你所用的计算机，其实同一个时间可以运行很多个程序。比如，我现在一边在浏览器里写这篇文章，后台同样运行着一个Python脚本程序。而这两个程序，是完全相互独立的。它们两个的指令完全并行运行，而不会产生依赖问题带来的“冒险”。

这么做似乎不需要什么新技术呀。现在CPU就是多核，本就可用多个不同CPU核心，去运行不同任务。
即使当时的Pentium 4单核，计算机本能同时运行多进程或多线程。
这超线程技术有什么特别用处？
无论是上面说的多个CPU核心运行不同的程序，还是在单个CPU核心里面切换运行不同线程的任务，在同一时间点上，一个物理的CPU核心只会运行一个线程的指令，所以其实我们并没有真正地做到指令的并行运行。

超线程可非如此。超线程CPU，是把一个物理层面CPU核心，“伪装”成两个逻辑层面的CPU核心。
这个CPU会在硬件层增加很多电路，使得可在一个CPU核心内部，维护两个不同线程的指令的状态信息。
如在一个物理CPU核心内部，会有双份PC寄存器、指令寄存器甚至条件码寄存器。如此，该CPU核心即可维护两条并行的指令状态。
外人来看，似有两个逻辑层面的CPU在同时运行。所以，超线程技术一般也叫同时多线程（Simultaneous Multi-Threading，SMT）技术。

但在CPU的其他功能组件，Intel不会提供双份。无论是指令译码器还是ALU，一个CPU核心仍只有一份。超线程并非真同时运行两指令，那就真物理多核。超线程目的是在一个线程A的指令，在流水线里停顿时，让另外一个线程去执行指令。因此时，CPU的译码器、ALU空出来，则另一线程B即可拿来干自己的事。线程B可没有对线程A里面指令的关联和依赖！

于是，CPU通过小代价，就实现了“同时”运行多个线程的效果。通常只要在CPU核心的添加10%左右的逻辑功能，增加可忽略不计的晶体管数量，就能达到这点。

所以并未增加真的功能单元，超线程只在特定场景下效果不错。一般在那些各线程“等待”时间较长的应用场景下。如需要应对很多请求的数据库应用，就很适合超线程。各指令都要等待访问内存数据，但并不需要做太多计算。

知道如何压榨超线程了吧？CPU计算并未跑满，但往往当前指令要停顿在流水线，等待内存里的数据返回。这时，让CPU里各个功能单元，去处理另外一个DB连接的查询请求就是最佳实践。

![](https://codeselect.oss-cn-shanghai.aliyuncs.com/cpu-z.png)
CPU Cores=4，但Threads=8。说明这CPU有4个物理的CPU核心，即4核CPU。但逻辑层面，它“装作”有8个CPU核心，可利用超线程同时运行8条指令。

## SIMD：咋加速矩阵乘法？

Instructions：MMX、SSE等。这些就是这CPU支持的指令集。MMX、SSE指令集引出最后一个提升CPU性能的技术方案，SIMD，单指令多数据流（Single Instruction Multiple Data）。

### SIMD性能

两段示例程序：

- 循环给一个list里每个数+1
- 实现相同功能，但直接调用NumPy库add方法

统计两段程序性能，调用Python的timeit库：

```py
$ python
>>> import numpy as np
>>> import timeit
>>> a = list(range(1000))
>>> b = np.array(range(1000))
>>> timeit.timeit("[i + 1 for i in a]", setup="from __main__ import a", number=1000000)
32.82800309999993
>>> timeit.timeit("np.add(1, b)", setup="from __main__ import np, b", number=1000000)
0.9787889999997788
>>>
```

两个功能相同代码性能却很大差异，足足差30多倍。也难怪所有用Python讲解数据科学的教程里，往往一开始就告诉你不要用循环，而要把所有计算都向量化（Vectorize）。

因为Python是一门解释性语言，所以性能差异大：

- 第一段程序的循环的每一次操作都需要Python解释器执行
- 第二段的函数调用是一次调用编译好的原生代码，所以才那么快？

直接用C语言实现1000个元素数组里每个数+1。发现即使C编译代码，还远低于NumPy。因NumPy直接用到SIMD指令，能并行进行向量操作。

使用循环一步一步计算叫SISD，单指令单数据（Single Instruction Single Data）。如多核CPU，它同时处理多个指令方式叫MIMD，多指令多数据（Multiple Instruction Multiple Dataa）。

### SIMD指令为啥这么快？

SIMD在获取数据和执行指令，都做到并行。一方面，从内存读取数据时，SIMD是一次性读取多个数据。

数组里面的每一项都是一个integer，即需 4 Bytes内存空间。Intel在引入SSE指令集时，在CPU里面添上了8个 128 Bits的寄存器。128 Bits也就是 16 Bytes ，也就是说，一个寄存器一次性可以加载 4 个整数。比起循环分别读取4次对应的数据，时间就省下来了。

![](https://codeselect.oss-cn-shanghai.aliyuncs.com/%E8%B6%85%E7%BA%BF%E7%A8%8B.png)
数据读取到后，在指令执行层面，SIMD可并行。4个整数各自加1，互相之前完全没有依赖，即无冒险问题。
只要CPU有足够多功能单元，就能同时计算，这加法就是4路同时并行，很省时间。

所以，对那些计算层面存在大量“数据并行”（Data Parallelism）的，使用SIMD很划算。在这大量“数据并行”，通常就是向量运算或矩阵运算。
过去通常是在进行图片、视频、音频的处理。最近几年则通常是在进行各种机器学习算法计算。

而基于SIMD的向量计算指令，也正是在Intel发布Pentium处理器的时候，被引入的指令集。当时的指令集叫作MMX，也就是Matrix Math eXtensions的缩写，中文名字就是矩阵数学扩展。而Pentium处理器，也是CPU第一次有能力进行多媒体处理。这也正是拜SIMD和MMX所赐。

从Pentium开始，能在电脑上听MP3、看VCD，不用买块“声霸卡”或“显霸卡”。那之前，电脑看VCD，需专门买能解码VCD的硬件插到电脑。

## 总结

超线程，其实是一个“线程级并行”的解决方案。它通过让一个物理CPU核心，“装作”两个逻辑层面的CPU核心，使得CPU可以同时运行两个不同线程的指令。虽然，这样的运行仍然有着种种的限制，很多场景下超线程并不一定能带来CPU的性能提升。但是Intel通过超线程，让使用者有了“占到便宜”的感觉。同样的4核心的CPU，在有些情况下能够发挥出8核心CPU的作用。而超线程在今天，也已经成为Intel CPU的标配了。

SIMD则是一种“指令级并行”的加速方案，或者我们可以说，它是一种“数据并行”的加速方案。在处理向量计算的情况下，同一个向量的不同维度之间的计算是相互独立的。而我们的CPU里的寄存器，又能放得下多条数据。于是，我们可以一次性取出多条数据，交给CPU并行计算。

正是SIMD技术的出现，使得我们在Pentium时代的个人PC，开始有了多媒体运算的能力。可以说，Intel的MMX、SSE指令集，和微软的Windows 95这样的图形界面操作系统，推动了PC快速进入家庭的历史进程。

> 参考
>
> - 《计算机组成与设计：硬件/软件接口》3.7章

