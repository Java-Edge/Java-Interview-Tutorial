# 04-还记得纸带编程吗？

以前写程序用“打孔卡（Punched Card），没法像今天，掏出键盘就能打字，而是要先在脑海/纸写出程序，然后在纸带/卡片上打洞。这样，要写的程序、要处理的数据，就变成一条条纸带或者一张张卡片，之后再交给当时的计算机去处理。

上世纪60年代晚期或70年代初期，Arnold Reinold拍摄的FORTRAN计算程序的穿孔卡照片：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/bf04fec806c90bf1bb8793d668333ac0.png)

人们在特定的位置上打洞或者不打洞，来代表“0”或者“1”。

计算机或说CPU本身，并没有能力理解这些高级语言，即使在2019年的今天，我们使用的现代个人计算机，仍然只能处理所谓的“机器码”，也就是一连串的“0”和“1”这样的数字。

那高级语言的程序，最终是怎么变成一串串“0”和“1”的？
这一串串“0”和“1”又是怎么在CPU中处理的？

## 1 软硬件接口中，CPU做了啥？

CPU(Central Processing Unit，中央处理器)就是计算机的大脑

- **硬件的角度**
  一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

- **软件工程师的角度**
  一个执行各种计算机指令（Instruction Code）的逻辑机器
  这里的计算机指令，就好比一门CPU能够听得懂的语言，即机器语言（Machine Language）

**不同的CPU能够听懂的语言不太一样**
Intel的CPU、ARM的CPU两者能听懂的语言就不一样，这样两种CPU各自支持的语言，就是两组不同的计算机指令集(Instruction Set)。
“Set”就是数学上的集合，代表不同的单词、语法。如果在自己电脑上写一个程序，然后把这个程序复制一下，装到自己的手机上，肯定是没办法正常运行的，因为这两者语言不通。
而一台电脑上的程序，简单复制一下到另外一台电脑上，通常就能正常运行，因为这两台CPU有着相同的指令集，它们语言相通。

**存储程序型计算机（Stored-program Computer）**
计算机程序，不可能只有一条指令，而是成千上万条指令组成
但CPU不能一直放着所有指令，所以程序平时是存储在存储器
这种程序指令存储在存储器里面的计算机，我们就叫作

**Plugboard Computer**
在没有现代计算机之前，有着聪明才智的工程师们，早就发明了一种叫Plugboard Computer的计算设备
在一个布满了各种插口和插座的板子上，工程师们用不同的电线来连接不同的插口和插座，从而来完成各种计算任务

IBM的Plugboard：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/038f011464530696607c98cb3fecac48.png)

## 2 编译=>汇编 代码=>机器码

代码咋变成一条条计算机指令，最后被CPU执行的？

### 2.1 案例

#### 代码示例

test.c

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/e0258962b1155cb3af226b7603d68d20.png)

#### 编译（Compile）成汇编代码

要让这段程序跑在Linux上，要把整个程序翻译成汇编语言（ASM，Assembly Language）的程序。

针对汇编代码，可再用汇编器（Assembler）翻译成机器码（Machine Code）。

这些机器码由“0”“1”组成的机器语言表示，这一条条机器码，就是一条条计算机指令。这样一串串的16进制数字，就是CPU能真正认识的计算机指令。

Linux可用gcc和objdump，把对应汇编代码和机器码都打印：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/84fd208d21e26a55d8b922fb83525dc7.png)

- 左侧一堆数字，就是一条条机器码
- 右边一系列的push、mov、add、pop等，这些就是对应的汇编代码

一行C语言代码，有时候只对应一条机器码和汇编代码，有时候则是对应两条机器码和汇编代码
汇编代码和机器码之间一一对应。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/6c96155b463d8080ffdc02325cf9d5c8.png)

实际在用GCC（GUC编译器套装，GUI Compiler Collectipon）编译器时，可直接把代码编译成机器码，为啥还需要汇编代码？那一串数字表示的机器码，摸不着头脑！

但即使你没学过汇编，看的时候多少也能“猜”出代码含义。汇编代码就是“**给程序员看的机器码**”
也正因为这样，机器码和汇编代码一一对应！

易记住add、mov这些指令，而8b 45 f8这样的指令，由于很难一下看明白是啥，所以非常难记忆：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/6e8c5f08c5b23fbc7e870ee05d1e4cc7.png)

从高级语言到汇编代码，再到机器码，就是一个日常开发程序，最终变成了CPU可以执行的计算机指令的过程。

## 3 解析指令和机器码

来看这一行行的汇编代码和机器指令，到底啥意思。

Intel CPU，有2000条左右的CPU指令，常见指令可分五类。

### 3.1 算术类指令

加减乘除，在CPU层面，都会变成一条条算术类指令

### 3.2 数据传输类指令

给变量赋值、在内存里读写数据，用的都是数据传输类指令。

### 3.3 逻辑类指令

逻辑上的与或非

### 3.4 条件分支类指令

日常的“if/else”

### 3.5 无条件跳转指令

写一些大一点的程序，我们常常需要写一些函数或者方法。调用函数时，就是发起一个无条件跳转指令：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/014b9ff3929172bec5305c60527d010e.png)

汇编器是怎么把对应的汇编代码，翻译成为机器码的。

不同CPU有不同指令集，对应不同的汇编语言和不同的机器码。
为方便快速理解机器码的计算方式，选用最简单的MIPS指令集，看机器码是如何生成的。

MIPS是一组由MIPS技术公司在80年代中期设计出来的CPU指令集。最近，MIPS公司把整个指令集和芯片架构都完全开源了。想要深入研究CPU和指令集的同学，推荐[一些资料](https://www.mips.com/mipsopen/)。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/99ca3155c3d5509941cbc7ff24b584d5.png)
MIPS的指令是一个32位的整数，高6位**操作码**（Opcode)：
代表这条指令具体是一条什么样的指令。
剩下的26位有三种格式，分别是：
**R指令**
一般做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量。而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。

**I指令**
通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这时，没有位移量和操作码，也没有第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。

**J指令**
一个跳转指令，高6位之外的26位都是一个跳转后的地址

```
add $t0,$s2,$s1
```

下面都用十进制来表示对应的代码，对应的MIPS指令的：

- opcode是0
- rs代表第一个寄存器s1的地址是17
- rt代表第二个寄存器s2的地址是18
- rd代表目标的临时寄存器t0的地址是8
- 因为不是位移操作，所以位移量是0

把这些数字拼在一起，就变成了一个MIPS的加法指令。
一般把对应的二进制数，用16进制表示。这里0X02324020。这个数字也就是这条指令对应的机器码。
![](https://img-blog.csdnimg.cn/20190812235613407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70)
回到开头我们说的打孔带

- 打孔代表1
- 没有打孔代表0

用4行8列代表一条指令来打一个穿孔纸带，那么这条命令大概就长这样：
![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/39a9f606e874614c4b1cc932aaa40f9b.png)

你应该学会了怎么作为人肉编译和汇编器，给纸带打孔编程了，不用再对那些用过打孔卡的前辈们顶礼膜拜了。

## 4 总结

打孔卡，其实就是一种存储程序型计算机。

只是这整个程序的机器码，不是通过计算机编译出来的，而是由程序员的人脑“编译”成一张张卡片的
对应的程序，也不是存储在设备里，而是存储成一张打好孔的卡片
但是整个程序运行的逻辑和其他CPU的机器语言没有什么分别，也是处理一串“0”和“1”组成的机器码而已。

我们看到了一个C语言程序，是怎么被编译成为汇编语言，乃至通过汇编器再翻译成机器码的。

除了C这样的编译型的语言之外，不管是Python这样的解释型语言，还是Java这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成CPU能够理解的机器码来执行的。

只是解释型语言，是通过解释器在程序运行的时候逐句翻译，而Java这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译成为机器码来最终执行。

## 编译型语言和解释型语言

两种不同的编程语言执行方式。它们在代码执行的过程中有明显的区别：

### 1. **定义和执行方式**

#### 编译型语言：

- **定义**：编译型语言是先将源代码编译成机器码（或中间代码），然后由计算机直接执行这些机器码。
- **执行方式**：
  1. **编译**：源代码通过编译器一次性翻译成机器码或中间代码。
  2. **执行**：编译后的机器码由操作系统或虚拟机执行。
- **示例语言**：C、C++、Go、Rust

#### 解释型语言：

- **定义**：解释型语言是由解释器逐行将源代码翻译成机器码并立即执行。
- **执行方式**：
  1. **解释**：解释器逐行读取源代码，将其翻译成机器码并立即执行。
- **示例语言**：Python、Ruby、JavaScript、PHP

### 2. **性能**

#### 编译型语言：

- **性能**：通常更高效，因为机器码是直接执行的，中间没有额外的翻译步骤。
- **优化**：编译器可以在编译过程中进行各种优化，提高代码执行效率。

#### 解释型语言：

- **性能**：通常较慢，因为每次执行都需要将代码翻译成机器码，且没有编译期优化。
- **即时编译**：一些解释型语言使用即时编译（JIT）技术，将部分代码在运行时编译成机器码，以提高性能（如 Java 的 HotSpot 和 Python 的 PyPy）。

### 3. **开发过程**

#### 编译型语言：

- **开发过程**：需要先编译再执行，这个过程比较长，编译过程中的错误在执行前就能发现。
- **调试**：编译错误和链接错误在编译阶段就能被发现，有助于提前解决问题。

#### 解释型语言：

- **开发过程**：无需编译，直接运行代码，开发过程更快速、更方便。
- **调试**：因为是逐行解释执行，错误通常在运行时发现，调试时可以立即看到效果。

### 4. **平台依赖性**

#### 编译型语言：

- **平台依赖性**：编译生成的机器码通常是平台相关的，不同的平台需要重新编译。
- **移植性**：需要跨平台时，需要在目标平台上重新编译源代码。

#### 解释型语言：

- **平台依赖性**：源代码通常是平台无关的，只要解释器能够在目标平台上运行，代码就能执行。
- **移植性**：高，只需要确保目标平台上有对应的解释器。

### 5. **代码分发**

#### 编译型语言：

- **代码分发**：通常分发的是编译后的可执行文件，不需要包含源代码。
- **隐私保护**：源代码不易泄露，因为用户运行的是编译后的机器码。

#### 解释型语言：

- **代码分发**：通常分发源代码或字节码（对于一些解释型语言，如 Python）。
- **隐私保护**：源代码可能会被用户查看或修改，隐私保护较弱。

### 总结

| 特性       | 编译型语言                 | 解释型语言             |
| ---------- | -------------------------- | ---------------------- |
| 定义       | 先编译再执行               | 逐行解释执行           |
| 性能       | 通常更高效                 | 通常较慢               |
| 开发过程   | 先编译再执行，编译时间较长 | 无需编译，开发快速     |
| 平台依赖性 | 依赖平台，需要重新编译     | 平台无关，解释器需支持 |
| 调试       | 编译时发现错误             | 运行时发现错误         |
| 代码分发   | 分发编译后的可执行文件     | 分发源代码或字节码     |
| 隐私保护   | 源代码保护较好             | 源代码易被查看         |

编译型语言和解释型语言各有优缺点，选择使用哪种语言通常取决于具体的应用场景和需求。编译型语言适合高性能和资源受限的环境，而解释型语言则适合快速开发和跨平台的应用。

> 参考
>
> - 《计算机组成与设计：软/硬件接口》第5版的2.17小节
> - 深入浅出计算机组成原理