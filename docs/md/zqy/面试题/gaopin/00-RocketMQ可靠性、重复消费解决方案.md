# 00-RocketMQ可靠性、重复消费解决方案
## RocketMQ 的消息可靠性如何保证？

RocketMQ 作为分布式消息中间件，肯定是要尽可能保证消息传输的 **可靠性** ，要保证消息的可靠性，先来思考一下从哪些方面保证呢？

这要看消息的生命周期，既然保证可靠性，那么就是要保证 A 发送给 B 的消息一定可以成功，那么首先要保证发送成功，其次要保证 B 接收成功，而在 RocketMQ 中，消息是先发送到 Broker 中了，那么还需要保证 MQ 在 Broker 中不会丢失

因此 RocketMQ 是从三方面保障了消息的可靠性：

- 保证 **生产者发送消息** 的可靠性
- 保证 **Broker 存储消息** 的可靠性
- 保证 **消费者消费消息** 的可靠性



## 发送消息的可靠性

RocketMQ 在发送端保证发送消息的可靠性主要就是通过 **重试机制** 来实现的

生产者发送消息分为了 **同步发送** 、 **异步发送** 、**单向发送** 三种方式：

- **同步发送** ：发送消息后，阻塞线程等待消息发送结果
- **异步发送** ：发送消息后，并不会阻塞等待，回调任务会在另一个线程中执行
- **单向发送** ：发送消息后，立即返回，不返回消息发送是否成功，因此不可以保证发送消息的可靠性



只有单向发送没有消息可靠性的保证，在 **同步** 和 **异步** 发送中，都可以通过设置发送消息的 **重试次数** 来保证发送端的可靠性，默认重试次数为 2 次

并且还可以设置如果发送失败，尝试发送到其他 Broker 节点

```java
// 同步设置重试次数
producer.setRetryTimesWhenSendFailed(3)
// 异步设置重试次数
producer.setRetryTimesWhenSendAsyncFailed(3);
// 如果发送失败，是否尝试发送到其他 Broker 节点
producer.setRetryAnotherBrokerWhenNotStoreOK(true);
```





## 存储消息的可靠性

**可靠性保证一：消息落盘存储保证消息的可靠性** 

在消息发送到 Broker 之后，Broker 会将消息存储在磁盘中，这样如果 Broker 异常宕机之后，可以读取磁盘中的数据来保证消息的 **可靠性** 



**RocketMQ 如何存储消息：**

RocketMQ 会先将消息写入到操作系统的 page cache 中，之后消息刷入磁盘分为了 **同步刷盘** 和 **异步刷盘** 两种方式， **默认是异步刷盘方式** 

page cache 就是将文件映射到内存中，这样直接操作内存比较快，避免了频繁的磁盘 IO

Broker 通过 **page cache** 和 **异步刷盘** 在保证消息可靠性的前提下，还尽可能提升了消息写入的性能



**在 Broker 端写入消息的流程如下：**

![image-20240325151146744](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240325151146744.png)

可以看到，这里写消息先写在了 jvm 的 **堆外内存** 中，而不是直接写在了 page cache 中，这是 RocketMQ 提供的 **transientStorePoolEnabled（瞬时存储池启用）机制** 来实现内存级别的读写分离

为什么要将消息先写在 **堆外内存** 呢？如果高并发的读写请求都直接落在 page cache 中的话，那么会导致对 page cache 的竞争太过于激烈，因此令写请求操作 **堆外内存** ，读请求操作 **page cache** ，实现 **读写分离** ，避免高并发情况下对 page cache 的激烈竞争





**可靠性保证二：主从复制保证 Broker 的消息可靠性**

上边是通过将消息写入磁盘来保证 Broker 存储端的消息可靠性，还有另一种方式：通过 **主从复制** 来保证消息的可靠性

在 Broker 主从复制时，会将 master 节点的消息同步到 slave 节点，slave 节点作为 master 节点的 **热备份** 存在，保证消息的可靠性



## 消费消息的可靠性

消费者为了保证消息的可靠性： **会先消费消息，再提交消息消费成功的状态** ，不过可能会出现 **重复消费** 的情况，因此需要业务方保证 **幂等性** 来解决重复消费的问题（可以建立一张消息消费表来避免重复消费）

**可靠性保证一：消息重试保证可靠性**

消费者只有返回 **CONSUME_SUCCESS** 才算消费完成，如果返回 **CONSUME_LATER** 则会按照不同的延迟时间再次消费，如果消费满 16 次之后还是未能消费成功，则会将消息发送到死信队列



**可靠性保证二：死信队列保证可靠性**

如果消息最终重试消费失败，并不会立即丢弃，而是将消息放入到了死信队列，之后还可以通过 MQ 提供的接口获取对应的消息， **保证消费消息的可靠性**





## RocketMQ 如何保证消费不被重复消费？

RocketMQ 可能会出现消息重复消费的情况：

- 生产者可能会重复生产消息
- 消费者也可能会重复消费消息

**重复消费** 就会带来问题，因此我们需要在业务设计时保证消费的 **幂等性** ，避免多次消费



**通过防重表来保证消费逻辑的幂等性：**

保证幂等性的话，可以建立一个 **消费记录表** ，在准备对消息进行消费时，将消息的唯一标识（比如传输订单信息，将订单的多个字段拼接成唯一标识，确定不重复即可）入到消费记录表中，并且对这个唯一标识建立 **唯一索引** ，通过唯一索引避免消息的重复消费



**消息消费的流程如下：**

1、开始消费消息

2、将消息的唯一标识插入到 **消费记录表** 中

3、如果插入成功，表明没有重复消费，可以执行消费逻辑

4、如果插入失败，捕捉唯一索引冲突异常，唯一索引冲突说明发生了重复消费，可以将该冲突异常 **（DuplicateKeyException）** 捕捉到，直接返回消费成功的提示



