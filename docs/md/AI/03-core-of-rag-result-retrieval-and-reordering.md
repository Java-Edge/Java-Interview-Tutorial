# RAG的核心-结果召回和重排序

## 1 完整RAG应用的检索流程

![](https://p.ipic.vip/a0stn3.png)

从用户输入Query到最终输出答案，整个流程包括Query预处理、检索召回、排序，每个环节都有不同方法提升检索效果。

## 2 Query预处理

### 2.1 意图识别

判断query问的啥类型问题，决定是否走RAG链路。

#### 示例1

- 深圳有啥玩的？ 闲聊问题
- VDB支持哪些检索算法？ 产品常见问题

#### 示例2

- 为啥某MongoDB实例内存占用过高？ 检查类问题
- 云Redis咋扩容？ 产品常见问题

#### 流程图

![](https://p.ipic.vip/oup930.png)

### 2.2 生成同义query

针对query生成同义句，不同问法提高召回，检索结果做合并。

示例1：**VDB支持啥检索算法**

- 列举一下VDB所支持的检索算法
- VDB有哪些可用的检索算法

示例2： **腾讯云向量数据库的优势是什么**

- 腾讯云向量数据库有哪些主要优点
- 腾讯云向量数据库的核心竞争力是什么

#### 流程图

![](https://p.ipic.vip/gyl5ct.png)

### 2.3 query标准化

针对query中的专有名词、简写、英文做标准化处理。

示例1：VDB支持哪些检索算法

xx云向量数据库支持哪些检索算法

示例2：COS如何上传对象

xx云对象存储如何上传对象

#### 流程图

![](https://p.ipic.vip/tcuags.png)

## 3 检索召回

![](https://p.ipic.vip/2qkawe.png)



| 索引类型 | 使用场景                                                     | 适用向量规模 | 召回率                 |
| -------- | ------------------------------------------------------------ | ------------ | ---------------------- |
| FLAT     | 暴力检索，召回率100%，但检索效率低。                         | 10万以内     | 最高，可保证100%召回率 |
| HNSW     | 基于图算法构建索引，可通过调整参数平衡查询日志和，具体信息：搜索效率。<br>检索效率高，但数据量大时内存消耗变高，具体请参考官方文档。 | 10万-1亿     | 95%+，可根据参数调整   |
| IVF系列  | 基于聚类算法构建的索引，可通过参数调整召回率，适用于上亿规模的数据集，检索效率高，内存占用低，写入效率高。 | 亿以上       | 95%+，可根据参数调整   |

每次召回时，如何提升结果的排序效果，使与Query更相关的结果更靠前？

1. **使用更有效的索引技术**：使用更高级的索引技术如倒排索引、压缩倒排索引等可以加速检索过程并提高结果的相关性。这些技术可以使得相似的文档在索引中更靠近，从而使得相关的结果更容易被召回
2. **优化检索模型**：使用适合任务的检索模型如BM25、BERT等，这些模型可以更好地捕捉文档之间的语义和相关性，从而提升召回结果的质量
3. **利用用户反馈**：收集用户的点击、浏览、收藏等行为反馈信息，通过机器学习算法不断优化排序模型，使得更符合用户兴趣的结果更容易被召回并排在前面
4. **引入上下文信息**：考虑查询的上下文信息，比如用户的地理位置、设备信息、搜索历史等，可以更好地理解用户意图，提升召回结果的相关性
5. 使用深度学习技术：如卷积神经网络、循环神经网络等，可更好学习文档之间的语义关系，从而提高结果的排序效果
6. **结合多种特征**：结合文本特征、结构特征、用户特征等多种特征进行综合排序，可以更全面地考虑到文档与查询之间的相关性

综合运用以上方法，可以在召回阶段有效提升结果排序效果，使得与Query更相关的结果更靠前。

Query预处理中，做了生成同义Query，最终应该如何合并检索结果？

1. **加权融合**：给每个查询生成的同义Query分配一个权重，并根据权重对检索结果进行加权融合。权重可以根据同义Query的相似性、生成方法的可靠性等因素来确定。
2. **组合排序**：将原始查询和同义查询的检索结果分别进行排序，然后将两个排序结果进行组合排序。可以根据不同的排序方法（如TF-IDF、BM25等）来进行组合排序，也可以采用机器学习模型进行组合排序。
3. **基于规则的合并**：制定一些规则来合并检索结果，例如保留两个查询中都包含的结果、去除重复的结果等。这种方法比较简单直接，但需要根据具体场景制定合适的规则。
4. **交叉验证**：将生成的同义Query和原始Query分别用于检索，并根据评估指标（如准确率、召回率等）来选择最优的检索结果。可以通过交叉验证或者在线评估来验证合并结果的效果。
5. **利用用户反馈**：收集用户对不同查询结果的反馈信息，根据反馈信息调整查询结果的排序和合并策略，使得更符合用户需求的结果更容易被展示在前面。

无论采用哪种方法，都需要结合具体的业务需求和数据特点来选择合适的合并检索结果的策略，以确保最终展示给用户的结果具有更高的相关性和质量。

如何在召回阶段，将召回的结果效果做得更优质，减少干扰信息对LLM的影响？

1. **使用更精准的召回模型**：使用更高效和精准的召回模型，如基于BERT、RoBERTa等预训练语言模型的语义匹配模型，能够更好地捕捉文本之间的语义关系，减少不相关文档的召回。
2. **利用领域知识和规则过滤**：结合领域知识和规则，对召回结果进行过滤和筛选，去除明显不相关或低质量的文档。例如，可以使用领域词典、实体识别等技术进行过滤。
3. **考虑上下文信息**：在召回阶段考虑用户的上下文信息，如搜索历史、用户兴趣等，通过个性化的方式调整召回结果，提高相关性。
4. **引入负采样**：在训练召回模型时引入负采样技术，增加负样本的多样性和难度，使得模型更好地区分干扰信息和相关信息。
5. **加入用户反馈机制**：收集用户对召回结果的反馈信息，如点击、滑动、停留时间等，根据反馈信息调整召回模型和排序策略，提高用户满意度和相关性。
6. **优化评估指标**：在评估召回结果时，不仅要关注传统的准确率、召回率等指标，还要考虑到与LLM输入的匹配度、语义相似度等指标，以更全面地评估召回结果的质量。

通过综合利用以上方法，在召回阶段可以更有效地优化召回结果，减少干扰信息对LLM的影响，提高模型的性能和效果。

## 4 排序

### 4.1 为啥要排序（Rerank）

Rerank：RAG中百尺竿头更进一步

![](https://p.ipic.vip/j84nai.png)

**Embedding模型局限性**：实际召回结果中，embedding无法完全反应出语义相似性，至少这K个文件的排名并非我们认为的从高分到低分。

排序模型目的在于，对召回内容有更合理排序结果，减少提供给模型的上下文长度，长度越长，对模型压力越大。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/974f3c64951c640dfd26adbf92ab2da1.png)