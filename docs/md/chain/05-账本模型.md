# 05-账本模型

## 0 XuperChain架构图



![](https://xuper.baidu.com/n/xuperdoc/v5.1/_images/arch.png)

五个部分来讲述这个 Super Chain 的技术原理：

1. 核心框架
2. 账本模型
3. 智能合约
4. 网络与共识
5. 其他

这是一个比较基本的阐述区块链框架的思路。

### 核心框架

首先介绍一下 Super Chain 的整体架构，它主要由 Super Core 这个核心引擎来构建。Super Core 分为三个部分：

1. **基础组件**：日志、存储、监控等关键组件，以及密码学库等基本组件。
2. **核心组件**：包括共识、合约、账本、网络安全模块，这些都是必备的。
3. **协议层**：各个模块对应的底层网络协议的实现。

Super Chain 的整体架构是一个多引擎架构，例如合约模块支持多类智能合约引擎。各模块都是标准化的，并且广域适用，类似于公有链的内容，很多节点都能访问，通过区块链浏览器或其他方式访问到网络。

Super Chain 构建了一个开放的网络，我们可以通过 Super Chain 的门户查看区块高度、交易总数、合约数等公开数据，也可以通过开放网络进行管理和操作。

## 1 账本模型

### 1.1 传统线性增长模型

传统的 MySQL 等系统采用线性增长的日志模型，通过一个 Leader 和多个 Follower 进行状态同步。这种方式有单点的带宽瓶颈问题。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/38810bc0f7252c9f2c3cd40baca1f839.png)

### 1.2 区块链共享账本模型

共享账本：树形增长。在去中心化网络中，可能同时选出多个合法的记账节点，导致分叉现象。通过默克尔树支持路径计算，轻节点可以查证交易是否存在于链上。P2P分散传播（Push和Pull有机结合）。

共享账本：树形增长（分支后续可能长成主干，所以分支Block也要存储）。



![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/82290ba210772e0ceea8040779500be5.png)

要支持路径计算，如：Block是否在主干上

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/049e1ac20732880eb904d38fe90c3225.png)

### 1.3 典型链式结构

区块链由一个个区块通过哈希指针逻辑连接，每个区块包含区块头和交易数据。最初应用于金融场景，防止双花问题。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/f0df9c7686feac3a65f7efb351530e40.png)

## 2 事务解决方案

区块链采用两大流派解决双花问题：

1. **账户模型**：类似银行账户，通过版本号防止重放攻击。
2. **UTXO 模型**：未花费的交易输出，类似现金支付，每个交易的输出来自之前某些交易的输入。

Xuper Chain 采用优化的 UTXO 模型，支持更广泛的数据领域，提升并发性能。

### 2.1 账户模型咋实现事务？

用递增的版本号检测冲突，本质串行。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/cc1d1d0c500ca91e95b793247b21d01f.png)

由于版本号冲突，这两个交易只能有一个成功。

### 2.2 UTXO模型咋实现事务?

通过判断交易的输入引用是否有冲突，并发性能更好。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/fba53283d4ef2beda286a63fa17badc8.png)

两笔交易都能成功，执行顺序还可以乱序。

#### 案例

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/11d08a001747ea96d4b8050debf60899.png)

奶奶给孙子50，让他买东西吃，然后孙子去小卖部花了0.5买了一根棒棒糖，剩下49.5，变成私房钱。小卖部收到小孩儿的0.5。

另一个小孩0.8买了两根棒棒糖，一根0.5，两根0.8，然后收到另一个小孩的那个钱，买了一根辣条0.3。然后它现在就有0.5，0.8和0.3。

然后他现在要把钱给自己的两个孙子，说你们一人八毛，一人八毛，拿去买买买，这就是一个UTFO过程。Xuper chain对ut so模型做了一些优化

## 3 优化

构造了一个更通用的事务模型。当前，以太坊、EOS 等都只能串行验证区块中的智能合约，因为它们的底层模型无法支持并行化的确定性验证。
然而， 经典的UTXO模型虽然并发性能好，但是只用于转账场景，能否用UTXO模型支持通用的智能合约呢?

- 普通UTXO模型：一个交易花的币一定来自早先某些交易赚的币
- 扩展UTXO模型：一个事务读取的数据一定来自早先某些交易的写入数据

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/d24681c0d0ff1f51e188a6c9ad989bdf.png)

T2和73可并行执行、即使不同节点乱序执行，得到D的结果也一致。

## 4 事务引擎架构图



![](https://my-img.javaedge.com.cn/javaedge-blog/2024/05/7f162ad61caeb79cb2b8747c7bf3378b.png)

通过客户端向这个全节点，它的一个utxo的这个引擎啊，发送一个交易，然后交易首先。它要进行一些缓存管理，然后去执行这个交易，然后做一个交易的预执行，然后假如说有冲突的话啊。怎么办？做一个冲突处理，如果说没问题的话呢，它就把它这个广播给这个就返回这个。读写即给这个客户端，

然后客户端就发起一笔交易，然后呢？交易交易如果没冲突的话，就通过这个共识算法选出一个记账节点，然后记账节点广播。广播之后，其他全节点去验证，验证没问题的话就落块。