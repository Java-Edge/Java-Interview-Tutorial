# Redis的整数数组和压缩列表

## 0 前言

整数数组、压缩列表的查找时间复杂度无很大优势，为啥Redis把它们作底层数据结构？

## 1 内存利用率

紧凑型数据结构，比链表占用内存少。毕竟大量数据存到内存，需尽可能优化提高内存利用率。

整数数组和压缩列表的entry都是实际的集合元素，一个挨一个保存，很节省内存空间：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/10/180b936a02a953503a2f349b26f55847.png)

## 2 数组对CPU高速缓存支持更友好

- 数组是连续内存空间
- 局部性原理

所以集合数据元素较少时，默认采用内存紧凑排列方式存储，同时利用CPU高速缓存不会降低访问速度。

当数据元素超过设定阈值，为避免查询时间复杂度太高，转为哈希和跳表数据结构存储。

CPU预读一个cache line大小数据，数组数据排列紧凑、相同大小空间保存的元素更多，访问下一个元素时，恰已在cpu缓存。若随机访问，就不能充分利用cpu缓存。如int元素，一个4byte，CacheLine默认64byte，可预读16个挨着的元素，若下次随机访问的元素不在这16个元素，就需重新从内存读取。

Redis底层使用数组和压缩链表对数据大小限制在64个字节以下，当大于64个字节会改变存储数据的数据结构，所以随机访问对CPU高速缓存没啥影响。

Redis List底层使用压缩列表，本质是将所有元素紧凑存储，所以分配的是一块连续内存空间，虽然数据结构本身没有时间复杂度优势，但：

- 节省空间
- 也避免一些内存碎片

因为按照一个cache line加载进cpu cache 按照当代cpu指令周期来看随机遍历的花销可忽略不计。

当一个缓存行无法加载完ziplist时，因为redis内部hash存储的是指针，也就是逻辑成环， 所以CPU加载开销无法忽视。此时只能转别的数据结构来解决，如skiplist。

参考：

- https://www.bigocheatsheet.com/