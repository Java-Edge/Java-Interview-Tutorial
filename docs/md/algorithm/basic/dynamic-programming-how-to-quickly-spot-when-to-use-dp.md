# 动态规划别死背：教你快速判断能否用DP

## 1 快速判断

DP能解决的问题规律：

### 1.1 多阶段决策最优解模型

DP适合解决的问题的模型。

一般用动态规划解决最优问题，而解决问题的过程，需经历多个决策阶段，每个决策阶段对应一组状态。

然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

### 1.2 三个特征

- 最优子结构
- 无后效性
- 重复子问题

#### ① 最优子结构

问题的最优解包含子问题的最优解。可通过子问题最优解，推导出问题最优解。

联系到动态规划问题的模型，可理解为，后面阶段的状态可以通过前面阶段的状态推得。

#### ② 无后效性

两层含义：

- 推导后面阶段状态时，只关心前面阶段的状态值，不关心这个状态是咋一步步推导出的
- 某阶段状态一旦确定，就不受之后阶段的决策影响

只要满足前面提到的动态规划问题模型，基本都会满足无后效性。

#### ③ 重复子问题

不同的决策序列，到达某个相同的阶段时，可能会产生重复状态。

## 2 案例

n*n的矩阵`w[n][n]`，存储正整数。棋子起始位左上角，终止位右下角。

- 棋子从左上角移动到右下角
- 每次只能向右或向下移动一位
- 从左上角到右下角，有不同路径
- 把每条路径经过的数字加起来，看作路径长度

求：从左上角移到右下角的min路径长？

![](https://p.ipic.vip/ansyg0.png)

### 2.1 是否符合【多阶段决策最优解】

从(0, 0)走到(n-1, n-1)，共需$2*(n-1)$步，对应$2*(n-1)$ 个阶段。每个阶段都有向右 or 向下两种决策，且每个阶段对应一个状态集合。

状态定义为`min_dist(i, j)`，表示从(0, 0)到达(i, j)的最短路径长度。所以，这是多阶段决策最优解问题。

![](https://p.ipic.vip/yxlciu.png)

### 2.2 是否符合【三个特征】

回溯法，画递归树，发现递归树有重复节点，即从左上角到节点对应的位置，有多种路线：

![](https://p.ipic.vip/trbztb.png)

#### 无后效性

走到(i, j)，只能通过(i-1, j)、(i, j-1)两个位置，即想计算(i, j)对应状态，只需关心(i-1, j)、(i, j-1)两个位置对应状态，而不关心棋子咋到达这俩位置。

仅允许往下、往右移，不允后退，所以，前面阶段的状态确定后，不会被后面阶段的决策所改变，符合无后效性。

#### 最优子结构

起始位置(0, 0)到(i, j)的最小路径，记作`min_dist(i, j)`。因只能往右、往下移动，只可能从`(i, j-1)`或`(i-1, j)`到达`(i, j)`。

--> 到达(i, j)的最短路径要么经过(i, j-1)，要么经过(i-1, j)，且到达(i, j)的最短路径肯定包含到达这两个位置的最短路径之一

--> min_dist(i, j)可通过min_dist(i, j-1)和min_dist(i-1, j)两个状态推导出来。说明符合“最优子结构”。

$min_dist(i, j)  = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))$

## 3 思路

解决DP问题的通用思路：

### 3.1 状态转移表法

一般能用DP的都能用回溯暴力搜索解决。

所以，可先用简单回溯算法解决，然后定义状态，每个状态表示一个节点，再画出递归树。
从递归树易看出是否存在**重复子问题**及重复子问题产因。以此寻找规律，看是否能用动态规划。

找到重复子问题后，有如下处理思路：

- 回溯加“备忘录”避免重复子问题。执行效率和动态规划无差
- 动态规划的解决方法，状态转移表法。先画出一个状态表。状态表一般二维，即二维数组。每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。将这个递推填表过程，翻译成代码，就是DP

尽管大部分状态表是二维，但若问题状态复杂，需很多变量表示，对应状态表可能就高维，不适用状态转移表法：

- 高维状态转移表不好画图表示
- 人脑不擅长思考高维东西

咋套用状态转移表法解决矩阵最短路径？从起点到终点有很多种不同走法，可穷举所有走法，然后对比找出一个最短走法。咋才能无重复、不遗漏穷举出所有走法？

#### 回溯法

```java
// 参数：i,j=当前所在行列，dist=起点走到当前点的路径长，w=矩阵数组，n=矩阵大小（行列数）
public void minDistBT(int i, int j, int dist, int[][] w, int n) {
    // 检查是否到达终点位置，即(n-1, n-1)的下一个位置(n, n)
    if (i == n && j == n) { // 如果当前i和j都等于n，说明已走过所有格子，到达终点
        if (dist < minDist) { // 比较当前路径长度dist和全局最小值minDist，若当前路径更短
            minDist = dist; // 更新全局最小值minDist为当前路径长dist
        }
        return; // 结束当前这条路径的递归，回退到上一个位置，尝试其他可能路径
    }

    // 尝试向下移动（下一行）
    if (i < n) { // 当前行i若小于，说明还没超出矩阵下边界，可往下
        minDistBT(i + 1, j, dist + w[i][j], w, n); // 递归调用自己：行号加1（i+1往下），列号不变（j），路径长度dist累加上当前位置的数值w[i][j]，继续向下走
    }
    // 尝试向右移动（下一列）
    if (j < n) { // 当前列j若小于，说明还没超出矩阵右边界，可往右
        minDistBT(i, j + 1, dist + w[i][j], w, n); // 递归调用自己：列号加1（j+1往右），行号不变（i），路径长度dist累加上当前位置的数值w[i][j]，继续向右走
    }
}
```

画递归树，寻找重复子问题。递归树中，一个状态（即一个节点）包含三个变量(i, j, dist)：

- i，j行列
- dist表示从起点到达(i, j)的路径长度

尽管(i, j, dist)不存在重复，但(i, j)重复很多。对于(i, j)重复节点，只需选择dist最小节点，继续递归求解：

![](https://p.ipic.vip/c07987.png)

#### 存在重复子问题

尝试是否可用DP。

画二维状态表，行、列表棋子所在位置，数值表示从起点到这个位置的最短路径。
按决策过程，不断状态递推演进，填状态表。

![](https://p.ipic.vip/p9k99f.png)



![](https://p.ipic.vip/42nwvb.png)

```java
// 参数：matrix矩阵数组，n矩阵大小
// 返回从起点(0,0)到终点(n-1,n-1)的最小路径长
public int minDistDP(int[][] matrix, int n) {
   // n*n二维数组作为状态转移表，存储从起点(0,0)到每个位置(i,j)的最小路径长
  int[][] states = new int[n][n];
  // 定义一个变量sum，用于累加路径长度，初始值为0
  int sum = 0;
  for (int j = 0; j < n; ++j) { // 循环遍历第一行的所有列，j从0到n-1
    sum += matrix[0][j]; // 将当前列位置的数值matrix[0][j]累加到sum中，因为第一行只能从左边过来，路径长度是前几列数值的累加
    states[0][j] = sum; // 将累加得到的sum存入状态表的第一行第j列，表示从起点到(0,j)的最小路径长度
  }
  sum = 0; // 重置sum为0，准备累加第一列的数据
  for (int i = 0; i < n; ++i) { // 循环遍历第一列的所有行，i从0到n-1
    sum += matrix[i][0]; // 将当前行位置的数值matrix[i][0]累加到sum中，因为第一列只能从上边过来，路径长度是前几行数值的累加
    states[i][0] = sum; // 将累加得到的sum存入状态表的第i行第0列，表示从起点到(i,0)的最小路径长度
  }
  for (int i = 1; i < n; ++i) { // 外层循环，从第2行开始遍历到最后一行，i从1到n-1
    for (int j = 1; j < n; ++j) { // 内层循环，从第2列开始遍历到最后一列，j从1到n-1
      states[i][j] = // 计算当前位置(i,j)的最小路径长度，并存入状态表
            matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]); // 当前位置的数值加上左边和上边路径长度的较小值，取最小值确保路径最短
    }
  }
  return states[n-1][n-1]; // 返回状态表右下角的值，即从起点(0,0)到终点(n-1,n-1)的最小路径长度
}
```

### 3.2 状态转移方程法

类似递归的思路。某问题如何通过子问题来递归求解，即最优子结构。根据最优子结构，写出递归公式，即状态转移方程。有了状态转移方程，代码就简单了。

一般有两种代码实现：

- 递归加“备忘录”
- 迭代递推

案例的状态转移方程：

```java
min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
```

#### 递归加“备忘录”

将状态转移方程翻译成来代码

```java
// 定义一个4x4的二维数组matrix，用来存储矩阵中的数字，每个数字代表从起点到这个位置的路径上要加的数值
private int[][] matrix = {{1, 3, 5, 9}, {2, 1, 3, 4}, {5, 2, 6, 7}, {6, 8, 4, 3}}; 
// 定义变量n，表示矩阵的大小，这里是4x4
private int n = 4;
// 定义一个4x4的二维数组mem，作备忘录，存储已计算过的从(0,0)到(i,j)的最小路径长度，避免重复计算
private int[][] mem = new int[4][4];

/**
 * 参数i和j表示当前要到达的位置的行列
 * 返回从(0,0)到(i,j)的最小路径长度
 * 调用minDist(n-1, n-1)
 */
public int minDist(int i, int j) { 
    if (i == 0 && j == 0) { // 若当前位置是起点(0,0)，则最小路径长度就是matrix[0][0]本身
        return matrix[0][0];
    }

    if (mem[i][j] > 0) { // 检查备忘录mem中是否已计算过从(0,0)到(i,j)的路径长度，如果大于0说明已计算过
        return mem[i][j]; // 直接返回备忘录中存储的值，避免重复计算
    }

    int minLeft = Integer.MAX_VALUE; // 初始化minLeft为一个很大的数，表示从左边过来的最小路径长度，初始设为最大值
    if (j - 1 >= 0) { // 若当前位置的左边存在，则可从左边过来
        minLeft = minDist(i, j - 1); // 递归调用minDist计算从(0,0)到左边位置(i,j-1)的最小路径长度
    }
    int minUp = Integer.MAX_VALUE; // 初始化minUp为一个很大的数，表示从上边过来的最小路径长度，初始设为最大值
    if (i - 1 >= 0) { // 如果当前位置的上边存在（行数i-1 >=0），则可从上边过来
        minUp = minDist(i - 1, j); // 递归调用minDist计算从(0,0)到上边位置(i-1,j)的最小路径长度
    }
    int currMinDist = matrix[i][j] + Math.min(minLeft, minUp); // 计算当前位置(i,j)的最小路径长度：当前位置的数值 + 从左或上边过来的最小路径长度的较小值
    mem[i][j] = currMinDist; // 将计算得到的最小路径长度存储到备忘录mem
    return currMinDist; // 返回当前计算的最小路径长度
}
```

不是每个问题都同时适合两种思路。

## 4 算法比较

- 贪心、回溯、动态规划归一类：解决问题的模型，都可抽象成多阶段决策最优解模型
- 分治单独作一类：尽管大部分也是最优解问题，但大部分都不能抽象成多阶段决策模型

回溯算法是“万金油”，基本能用动态规划、贪心的问题，都可用回溯。相当于穷举搜索。穷举所有情况，再对比得到最优解。但回溯算法时间复杂度高，指数级，只能解决小规模数据问题。

尽管动态规划比回溯算法高效，但不是所有问题都可动态规划。能用动态规划的问题，需满足三个特征。

重复子问题方面：

- 分治算法要求分割成的子问题，不能有重复子问题
- 动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题

贪心是动态规划的一种特殊情况。它解决问题更高效，代码更简洁。但它可解决问题更有限，需满足三个条件：最优子结构、无后效性和贪心选择性。最优子结构、无后效性跟动态规划无异。“贪心选择性”指通过局部最优选择，能产生全局最优选择。每个阶段，都选择当前看起来最优决策，所有阶段决策完成后，最终由这些局部最优解构成全局最优解。

## 5 总结

两种动态规划的思路：

- 状态转移表法：回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码
- 状态转移方程法：找最优子结构-写状态转移方程-将状态转移方程翻译成代码