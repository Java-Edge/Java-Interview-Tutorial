# 详解雪花算法

### 外置Snowflake

雪花算法Snowflake，Twitter公司分布式项目采用的ID生成算法。

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/06/349f2bba7c6850cebd12391845baae99.jpg)

这个算法生成的ID是一个64位的长整型long：

- 1位符号位，值为 0,没有实际意义，主要为兼容长整型的格式
- 41位时间戳，记录本地的毫秒时间。41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂,一年所使用的毫秒数是365 * 24 * 60 * 60 * 1000,即 69.73 年。即ShardingSphere 的 SnowFlake 算法的时间纪元从 2016 年 11 月 1 日零点开始,可以使用到 2086 年
- 10 bit工作进程位，机器ID，机器就是生成ID的节点，用10位长度给机器做编码，那意味着最大规模可以达到1024个节点（2^10）。前 5 个 bit 代表机房 id,后 5 个 bit 代表机器i
- 12位序列号，某个机房某台机器上在一毫秒内同时生成的 ID 序号。如果在这个毫秒内生成的数量超过 4096(即 2 的 12 次幂),那么生成器会等待下个毫秒继续生成。序列的长度直接决定了一个节点1毫秒能够产生的ID数量，12位就是4096（2^12）

据数据结构推算：

- 每秒可以产生 26 万个自增可排序的 ID
- 支持TPS可达（2^22*1000，419万左右），够绝大多数系统。

但实现雪花算法时，注意时间回拨影响。机器时钟若回拨，产生的ID就可能重复，需在算法中特殊处理。

SnowFlake 算法依赖时间戳，需考虑时钟回拨，即服务器因时间同步，导致某部分机器的时钟回到了过去的时间点。时间戳的回滚肯定会导致生成一个已使用过的ID，因此默认分布式主键生成器提供一个最大容忍的时钟回拨ms数：

- 若时钟回拨时间超过最大容忍的毫秒数阈值，则程序报错
- 在可容忍范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后，再继续工作