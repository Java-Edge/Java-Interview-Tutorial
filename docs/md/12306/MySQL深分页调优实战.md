# MySQL深分页调优实战

## 1 案例背景

商品评论系统数据量为十亿量级，对评论数据库做分库分表后，单表的评论数据在百万级。每个商品的所有评论都放在一个库的一张表，确保用户在分页查询一个商品的评论时，直接从一个库的一张表里执行分页查询语句即可。

热点商品销量多达100w，商品评论可能多达10w万条，而有些用户就爱看商品评论，他就不停对某热点商品评论一页页翻，不断进行分页。有时还会用上分页跳转功能：直接输入想跳到第几页。

这就涉及一个商品几十w评论的深分页问题。简化后的评论表分页查询SQL：

```sql
SELECT * 
FROM comments
# 选择了查看某个商品的评论
WHERE product_id ='xx'
# 只看好评
and is_good_comment='1' 
ORDER BY id desc
# 看第5001页评论，则limit的offset=(5001 - 1) * 20
LIMIT 100000,20
```

评论表最核心的索引**index_product_id**，所以正常肯定走这索引：

## 2 执行过程

- 根据product_id ='xx'条件，从表里先筛出指定商品的评论数据

- 再按 is_good_comment='1'，筛选出该商品的所有好评

  但**index_product_id**索引里并无**is_good_commet**字段值，所以需回表。即，对该商品的每条评论，都要进行一次回表，根据id找到那条数据，取出is_good_comment字段值，接着比对is_good_comment='1'条件，筛选符合的数据。假设商品评论有几十w条，岂不是要几十w次回表？虽然每次回表都是根据id在聚簇索引快速查找，但撑不住你每条数据都回表呀！

- 接着对筛选完毕的所有满足**WHERE product_id ='xx' and is_good_comment='1'**的数据，假设有10w条，就按id做倒序排序，此时还得基于临时磁盘文件进行倒序排序，又耗时很久

- 排序完毕，基于limit 100000,20，获取第5001页的20条数据

- 最后返回

该过程有几十w次回表查询，还有十多w条数据的磁盘文件排序，所以要跑个1~2s，如何优化？

## 3 SQL优化

- 有时基于商品的品类去查商品表，是尽量避免扫描聚簇索引，因为可能找不到你指定品类的商品而出现聚簇索引全表扫描问题，所以强制使用联合索引，快速定位到数据，这过程中因无需回表，所以效率较高
- 有时又是直接根据id临时磁盘文件排序后找到20条分页数据，再回表查询20次，找到20条商品的完整数据。因为不涉及大量回表，所以这么做基本合适，性能通常1s内。

但本案例也与众不同，因为

```sql
WHERE product_id ='xx' 
	and is_good_comment='1'
```

这俩条件不是一个联合索引，所以会出现大量回表！耗时严重。

### 优化后的SQL

因此对该案例，一般采取如下方式改造分页查询语句：

```sql
SELECT *
from comments a,
     (
         SELECT id 
         FROM comments 
         WHERE product_id = 'xx' 
           and is_good_comment = '1' 
         ORDER BY id desc 
         LIMIT 100000,20) b
WHERE a.id = b.id
```

该SQL的执行计划就会彻底改变其执行方式。

### 执行流程

先执行子查询，会使用PRIMARY聚簇索引，按id值的倒序方向进行扫描，扫描过程中就把符合如下条件的数据筛选出来：

```sql
WHERE product_id ='xx' and is_good_comment='1'
```

比如这里筛选出10w条数据，并不需要把符合条件的数据都找到，因为limit 100000,20，理论上，只要有100000+20条符合条件的数据，且按id有序，就能根据limit 100000,20提取5001页的这20条数据。

执行计划里会

- 针对这个子查询的结果集，一个临时表，进行全表扫描，拿到20条数据
- 再对20条数据遍历，每条数据都按id去聚簇索引查找完整数据

所以本案例，反而是优化成这种方式来执行分页更合适，他只有一个扫描【聚簇索引】筛选符合你分页所有数据的成本：

- 分页越深，扫描数据越多
- 分页越浅，扫描数据就越少

然后再做这20条数据的20次回表即可！

SQL调优无银弹：

- 比如第二个案例，按顺序扫描【聚簇索引】可能会因找不到数据，导致亿级数据的全表扫描，所以必须得根据二级索引查找

- 但该案例，因为前提是做了分库分表，评论表单表数据一般在100w左右，所以首先，他即使一个商品没有评论，有全表扫描，也绝对不会像扫描上亿数据表那么慢

  其次，若你根据**product_id**二级索引查找，反而可能出现几十w次回表查询，所以二级索引查找方式反而不适合，而按照聚簇索引顺序扫描的方式更好。

所以要具体情况具体分析，到底慢在哪儿，再对症优化。