# Flink对数据延迟的解决方案！

## 1 前言

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/08/052c9170d23146a66d0d2fbf27c28189.png)

一系列数据（Data-5, Data-4, Data-1, Data-3, Data-2）按一定顺序排列。

异常：数据到达顺序与它们实际发生时间顺序不一致。按照时间戳来看，Data-1最先发生，但却排在Data-4和Data-5之后。

Data-1即为延迟数据，因为它比Data-4和Data-5更早发生，但更晚到达。

注意 data-1 只是延迟，不是丢失了！

## 2 数据延迟的影响

### 2.1 影响计算结果

在Flink的窗口计算中，乱序数据会导致窗口的关闭时机不准确，从而影响计算结果。如若按照窗口大小来划分，Data-1可能会被分配到一个错误的窗口中。

### 2.2 实时性降低

延迟数据的存在会降低Flink处理数据的实时性。如果Data-1承载着重要的实时信息，那么延迟到达会影响决策的时效性。

### 2.3 数据丢失风险

某些情况下，严重的延迟数据甚至可能导致数据丢失。例如，如果窗口已经关闭，而迟到的数据又无法被重新处理，那么这些数据就会丢失。

## 3 导致数据延迟的原因

- **网络传输延迟:** 数据在网络传输过程中可能遇到拥塞、丢包等问题，导致延迟。
- **数据源产生延迟:** 数据源本身可能存在延迟，例如数据库查询缓慢、传感器数据采集不及时。
- **Flink任务处理瓶颈:** Flink任务的并行度、资源配置等因素可能导致处理速度跟不上数据到达的速度。
- **Watermark设置不合理:** Watermark是Flink用来处理乱序数据的重要机制，如果Watermark设置不合理，也会导致数据延迟问题。

## 4  解决思路

- 使用事件时间作为标准

- 设置水位线：根据数据特性和业务需求，合理设置Watermark生成策略。

- 设置允许延迟的时间：对于允许一定程度的延迟，可以在窗口定义时设置允许迟到的时间。在窗口关闭后，仍然会等待一段时间，以接收迟到的数据

## 5 步骤

1. 定义窗口时间
2. 设置：水位线 为最大事件时间 - 允许延迟的时间

### 5.1 触发窗口计算

1. 水位线 > 窗口时间：当水位线超过窗口的结束时间，保证了窗口内的数据基本都到达了，避免过早触发计算导致结果不准确。
2. 窗口内有数据：这个条件保证了窗口计算是有意义的，避免对空的窗口进行计算。仅当窗口内存在数据时，才会触发计算，即使水位线已超过窗口时间

### 5.2 案例

假设现在：

- 窗口时间=10s
- 允许延迟的时间 =3.5s
- 水位线=最大EventTime -允许延迟的时间

触发窗口计算条件：

- 水位线>窗口时间
- 窗口内有数据

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/08/7673c3876e7eb1d9fd65e4195a2abe8c.png)

**事件1：** 表示一个到达Flink系统的事件，其事件时间为8。

**窗口时间：** 设置为10s，即每10s生成一个新窗口。

**允许延迟时间：** 设置3.5s，表示系统允许事件到达的时间延迟最多为3.5s。

**水位线：** 水位线是Flink用于跟踪事件时间的一个特殊标记，它的计算方式为：最大事件时间 - 允许延迟时间。在当前示例中，水位线为max(8) - 3.5 = 4.5<10，所以不触发计算。

事件二来了，看起来它是个延迟事件了。但依旧不能触发计算：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/08/d17a17842f499c521d87e002f95c4b91.png)

事件三来了，开始触发计算了：

![](https://my-img.javaedge.com.cn/javaedge-blog/2024/08/008676b8fc6a7bacf57825f56b21b13d.png)

但即便如此，对那些超长延迟的数据还是无法计算。处理方案：

- 单独搜集，稍后处理
- 完全不处理，直接丢弃