# Flink状态管理

## 1 无状态计算和有状态计算

状态：用来保存中间的计算结果。

根据状态是否需要保存中间结果，分为无状态计算、有状态计算。

### 1.1 无状态计算

- 每个事件的处理都是独立的，不依赖于之前的事件。
- 没有需要持久化的状态。
- 例如：计算数据流中的平均值。

### 1.2 有状态计算

- 事件的处理依赖于之前事件的计算结果。
- 需要保存中间状态，以便后续计算使用。
- 例如：窗口操作（如滑动窗口、滚动窗口）、会话窗口等。

### 1.3 为什么要区分？

- 优化性能：对于无状态计算，Flink可以进行更激进的优化，例如并行度更高、容错机制更简单。
- 实现复杂计算：有状态计算可以实现更复杂的计算逻辑，例如状态聚合、会话窗口等。
- 保证数据一致性：有状态计算需要保证状态的一致性，以确保计算结果的正确性。

### 1.4 总结

- **Flink的状态** 是指在计算过程中保存的中间结果。
- **无状态计算** 不需要保存状态，每个事件的处理都是独立的。
- **有状态计算** 需要保存状态，后续的计算依赖于之前的计算结果。
- 根据计算的复杂性和对状态的需求，选择合适的计算类型可以提高Flink应用程序的性能和可靠性。

**比喻：**

- **无状态计算** 就像流水线上的产品，每个产品都是独立的，不需要知道前面的产品是什么。
- **有状态计算** 就像生产线上的累积，每个产品的生产都依赖于前面的生产结果，需要保存中间的半成品

## 2 Flink状态

Flink流处理过程中，为了保存计算的中间结果或者一些上下文信息而维护的一种数据结构。这些状态可以是计数器、窗口信息或更复杂的数据结构。

**Flink状态的分类** 是根据Flink系统是否负责管理这些状态而划分：

### 2.1 原始状态（Raw State）

- 由用户自己管理，Flink不负责状态的持久化、容错和恢复。
- 用户需要自行实现状态的序列化、反序列化以及在故障发生时的恢复机制。
- 灵活性高，但实现复杂度也较高。

### 2.2 托管状态（Managed State，推荐）

- 由Flink系统统一管理，Flink会负责状态的持久化、容错和恢复
- 用户只需要定义状态的类型，Flink会自动处理底层的细节
- 易于使用，但灵活性相对较低

还可细分为：

#### KeyedState（键控状态）

- **特点：** 与特定的键绑定在一起
- **作用：** 用于保存与键相关的状态信息，比如窗口聚合的结果、会话状态等
- **适用场景：** 需要对不同键的数据进行独立的状态维护

#### OperatorState（算子状态）

- **特点：** 与整个算子关联，不与特定的键绑定
- **作用：** 用于保存整个算子级别的状态信息，比如定时器、广播变量等
- **适用场景：** 需要在整个算子范围内共享的状态

区别：

- **KeyedState** 和 **OperatorState** 是Flink中两种重要的状态类型
- 它们的区别在于与键的绑定关系以及作用域
- 选择合适的状态类型对于优化Flink应用程序的性能和正确性至关重要

选型：

  - 如果需要对不同键的数据进行独立的状态维护， **KeyedState**
  - 如果需要在整个算子范围内共享状态， **OperatorState**

- **状态后端：** Flink支持多种状态后端，如内存、RocksDB等，可以根据不同的业务需求选择合适的状态后端

- **状态的序列化和反序列化：** Flink提供了多种序列化机制，可以根据状态数据的特点选择合适的序列化方式

- **状态的容错：** Flink通过定期创建状态快照来实现状态的容错

### 2.3 小结

Flink将状态分为原始状态和托管状态，是为了提供不同的状态管理方式，以满足不同场景下的需求。用户可以根据自己的业务需求和对Flink的熟悉程度，选择合适的状态管理方式。

**选择原始状态的场景**

- 需要对状态有完全的控制权
- 对状态的性能要求非常高
- 需要自定义的状态序列化和反序列化机制

**选择托管状态的场景**

- 希望简化状态管理的复杂度
- 需要利用Flink提供的状态管理特性，如状态快照、状态恢复等
- 对状态的性能要求不是特别高

**总结来说，托管状态是Flink推荐的方式，它能大大简化状态管理的复杂度，提高开发效率。**