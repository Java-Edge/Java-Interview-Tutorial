# RabbitMQ消费端幂等性概念及解决方案

## 1 什么是幂等性

用户对于同一操作发起的一次请求或者多次请求的结果是一致的。

如数据库乐观锁，执行更新操作前：

- 先去数据库查询version
- 然后执行更新语句
- 以version作为条件，如果执行更新时有其他人先更新了这张表的数据，那么这个条件就不生效了，也就不会执行操作了

通过这种乐观锁的机制来保障幂等性。

## 2  Con幂等性

### 2.1 什么是Con幂等性

消费端实现幂等性，即消息永远不会消费多次，即使收到多条一样消息。

在业务高峰期最容易产生消息重复消费问题：当Con消费完消息后给Pro返回ack时，由于网络中断，导致Pro未收到确认信息，该条消息就会重新发送并被Con消费，但实际上该消费者已成功消费，就导致重复消费。

### 2.2 主流幂等性实现方案

#### ① 唯一ID+指纹码

利用DB主键去重：

```sql
SELECT COUNT(1) FROM T_ORDER 
		WHERE ID = 唯一ID
		AND IS_CONSUM = 指纹码
```

唯一ID：业务表的主键

指纹码：为区别每次正常操作的码，每次操作时生成指纹码。可用时间戳+业务编号或标志位（视业务场景而定）

优势：实现简单

弊端：高并发下有数据库写入的性能瓶颈

解决方案：根据ID进行分库分表算法路由

##### 小结

先根据消息生成一个全局唯一ID，然后加上一个指纹码。指纹码不一定是系统生成，而是一些外部规则或内部业务规则去拼接，就是为保障这次操作的绝对唯一性。

ID + 指纹码拼接好的值作为数据库主键，即可去重。消费消息前，先去数据库查询这条消息的指纹码标识：

- 不存在，就执行insert
- 存在，代表已被消费，就不需要管了

#### ② 利用Redis的原子性

需考虑：

- 是否要数据落库。若落库，数据库和缓存如何做到原子性
- 若不落库，都存储到缓存，如何设置定时同步策略

这里只提Redis原子性去解决MQ幂等性重复消费问题

> MQ的幂等性问题，根本在于Pro未正常接收ACK，可能是网络抖动、网络中断导致

##### 实现

Con消费开始时，将ID放入Redis BitMap。Pro每次生产数据时，从Redis的BitMap对应位置若不能取出ID，则生产消息发送，否则不进行消息发送。

有人说，万一Con、Pro的Redis命令执行失败咋办，虽然又出现重复消费又出现Redis非正常执行命令可能性极低，万一呢？可在Redis命令执行失败时，将消息落库，每日用定时器，对这种极特殊的消息进行处理。