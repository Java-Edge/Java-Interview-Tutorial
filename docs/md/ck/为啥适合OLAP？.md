# 为啥适合OLAP？

## 1 简介

ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。

传统行式数据库系统，数据按如下顺序存储：

| Row  | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
| ---- | ----------- | ---------- | ------------------ | --------- | ------------------- |
| #0   | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1   | 90329509958 | 0          | Contact us         | 1         | 2016-05-18 08:10:20 |
| #2   | 89953706054 | 1          | Mission            | 1         | 2016-05-18 07:38:00 |
| #N   | …           | …          | …                  | …         | …                   |

处于同一行中的数据总是被物理存储在一起。

常见行式数据库系统有：`MySQL`、`Postgres`。

列式数据库系统中，数据按如下顺序存储：

| Row:        | #0                  | #1                  | #2                  | #N   |
| ----------- | ------------------- | ------------------- | ------------------- | ---- |
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | …    |
| JavaEnable: | 1                   | 0                   | 1                   | …    |
| Title:      | Investor Relations  | Contact us          | Mission             | …    |
| GoodEvent:  | 1                   | 1                   | 1                   | …    |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | …    |

这些示例只显示了数据排列顺序。来自不同列的值被单独存储，来自同一列的数据被存储在一起。

常见的列式数据库有： Vertica、 Paraccel (Actian Matrix，Amazon Redshift)、 Sybase IQ、 Exasol、 Infobright、 InfiniDB、 MonetDB (VectorWise， Actian Vector)、 LucidDB、 SAP HANA、 Google Dremel、 Google PowerDrill、 Druid、 kdb+。

不同的数据存储方式适用不同的业务场景，数据访问场景包括：

- 进行了何种查询、多久查询一次及各类查询的比例
- 每种类型的查询(行、列和字节)读取多少数据
- 读取数据和更新之间的关系
- 使用的数据集大小及如何使用本地的数据集
- 是否使用事务及它们是如何进行隔离
- 数据的复制机制与数据的完整性要求
- 每种类型的查询要求的延迟与吞吐量等

系统负载越高，依据使用场景进行定制化就越重要，并且定制将会变的越精细。没有一个系统能够同时适用所有不同的业务场景。如果系统适用于广泛的场景，在负载高的情况下，要兼顾所有的场景，那么将不得不做出选择。是要平衡还是要效率？

## OLAP场景的关键特征

- 绝大多数是读请求
- 数据以相当大的批次(> 1000行)更新，而不是单行更新；或根本没更新
- 已添加到数据库的数据不能修改
- 对于读取，从数据库提取相当多的行，但只提取列的一小部分
- 宽表，即每个表包含着大量的列
- 查询相对较少(通常每台服务器每秒查询数百次或更少)
- 对于简单查询，允许延迟约50毫秒
- 列中的数据相对较小：数字和短字符串(例如，每个URL 60个字节)
- 处理单个查询时需要高吞吐量(每台服务器每秒可达数十亿行)
- 事务不是必须的
- 对数据一致性要求低
- 每个查询有一个大表。除了他以外，其他的都很小。
- 查询结果明显小于源数据。换句话说，数据经过过滤或聚合，因此结果适合于单个服务器的RAM中

易看出，OLAP场景与其他通常业务场景(如OLTP或K/V)有很大不同， 因此想要使用OLTP或KV DB去高效的处理分析查询场景，并非很完美的适用方案。如使用OLAP数据库去处理分析请求通常要优于使用MongoDB或Redis去处理分析请求。

### 列式DB更适合OLAP场景的原因

对大多数查询，处理速度至少提高100倍：

### 行式

![Row oriented](https://clickhouse.com/docs/assets/images/row-oriented-d515facb5bffb48cbd09dc7d064c8816.gif#)

列式：

![Column oriented](https://clickhouse.com/docs/assets/images/column-oriented-b992c529fa4085b63b57452fbbeb27ba.gif#)



### 输入/输出

1. 针对分析类查询，通常只需要读取表的一小部分列。在列式DB中你能只读取你需要的数据。如若只需读取100列中的5列，这将帮助你至少减少20倍I/O
2. 由于数据总是打包成批量读取，所以压缩很容易。同时数据按列分别存储这也更容易压缩。进一步降低I/O容量
3. 由于I/O降低，帮助更多数据被系统缓存

如查询【统计每个广告平台的记录数量】需要读【广告平台ID】列，它在未压缩时需1字节存储。若大部分流量不是来自广告平台，那这列至少可以以十倍的压缩率被压缩。当采用快速压缩算法，其解压速度最少在十亿字节(未压缩数据)每秒。换句话说，这查询可在单服务器上以每秒大约几十亿行的速度进行处理。这实际上是当前实现的速度。

### CPU

由于执行一个查询需要处理大量行，因此在整个向量上执行所有操作将比在每行上执行所有操作更加高效。同时这将有助于实现一个几乎没有调用成本的查询引擎。如你不这样做，使用任何一个机械硬盘，查询引擎都不可避免停止CPU以等待。所以，在数据按列存储并按列执行很有意义。

有两种方法：

1. 向量引擎：所有的操作都是为向量而不是为单个值编写的。这意味着多个操作之间的不再需要频繁的调用，并且调用的成本基本可以忽略不计。操作代码包含一个优化的内部循环。
2. 代码生成：生成一段代码，包含查询中的所有操作

这不应该在一个通用数据库中实现的，因为这在运行简单查询时没有意义。但也有例外，如MemSQL使用代码生成来减少处理SQL查询的延迟(只是为了比较，分析型数据库通常需要优化吞吐而不是延迟)。

为提高CPU效率，查询语言必须是声明型的(SQL或MDX)或至少一个向量(J，K)。 查询应该只包含隐式循环，允许进行优化。