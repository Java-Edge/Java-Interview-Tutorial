**1、设置过期时间**

*   expire key time(s)--这是最常用的方式
*   setex(String key, int seconds, String value)--字符串独有的方式


**注意**：

*   除了string独有设置过期时间方法，其他类型都需要依靠expire方法来设置时间
*   如果没有设置时间，那缓存就是永不过期
*   如果设置了过期时间，之后又想让缓存永不过期，使用persist key

**2、三种过期策略**

*   定时删除
    *   含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
    *   优点：保证内存被尽快释放
    *   缺点：
        *   若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
        *   定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
        *   没人用
*   惰性删除
    *   含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
    *   优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
    *   缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
*   定期删除
    *   含义：每隔一段时间执行一次删除过期key操作
    *   优点：
        *   通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
        *   定期删除过期key--处理"惰性删除"的缺点
    *   缺点
        *   在内存友好方面，不如"定时删除"
        *   在CPU时间友好方面，不如"惰性删除"
    *   难点
        *   合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

**注意**：

*   上边所说的数据库指的是内存数据库，默认情况下每一台redis服务器有16个数据库（关于数据库的设置，看下边代码），默认使用0号数据库，所有的操作都是对0号数据库的操作
```
# 设置数据库数量。默认为16个库，默认使用DB 0，可以使用"select 1"来选择一号数据库
# 注意：由于默认使用0号数据库，那么我们所做的所有的缓存操作都存在0号数据库上，
# 当你在1号数据库上去查找的时候，就查不到之前set过得缓存
# 若想将0号数据库上的缓存移动到1号数据库，可以使用"move key 1"
databases 16
```
*   memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）
*   对于惰性删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）

**3、Redis采用的过期策略**

惰性删除+定期删除

*   惰性删除流程
    *   在进行get或setnx等操作时，先检查key是否过期，
    *   若过期，删除key，然后执行相应操作；
    *   若没过期，直接执行相应操作
*   定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）
    *   遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16）
        *   检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
            *   如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
            *   随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
            *   判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。

**注意**：

*   对于定期删除，在程序中有一个全局变量current_db来记录下一个将要遍历的库，假设有16个库，我们这一次定期删除遍历了10个，那此时的current_db就是11，下一次定期删除就从第11个库开始遍历，假设current_db等于15了，那么之后遍历就再从0号库开始（此时current_db==0）
*   **由于在实际中并没有操作过定期删除的时长和频率，所以这两个值的设置方式作为疑问？**

**4、RDB对过期key的处理**

过期key对RDB没有任何影响

*   从内存数据库持久化数据到RDB文件
    *   持久化key之前，会检查是否过期，过期的key不进入RDB文件
*   从RDB文件恢复数据到内存数据库
    *   数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）

**5、AOF对过期key的处理**

过期key对AOF没有任何影响

*   从内存数据库持久化数据到AOF文件：
    *   当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
    *   当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
*   AOF重写
    *   重写时，会先判断key是否过期，已过期的key不会重写到aof文件
