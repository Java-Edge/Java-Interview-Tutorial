涉及到数据更新：数据库和缓存更新，就容易出现缓存和数据库间的数据一致性问题：

1. 如果先删了缓存，还没有来得及写MySQL，另一个线程就来读，发现缓存空，则去数据库读取数据写入缓存，此时缓存中为脏数据
2. 如果先写库，在删除缓存前，写库线程挂掉，没有删掉缓存

由于并发读写，没法保证顺序，就会出现缓存和数据库的数据不一致。

如何解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。

# 延时双删策略
写DB前后都执行`redis.del(key)`，并设定合理超时时间。

## 执行流程
1. 先删除缓存
2. 再写数据库
3. 休眠xx毫秒（根据具体业务时间）
4. 再次删除缓存

xx毫秒怎么确定？

需要评估项目读数据业务逻辑耗时,以确保读请求结束，写请求可删除读请求造成的缓存脏数据。

该策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。

# 设置缓存过期时间
理论上，设置缓存过期时间，是保证最终一致性的解决方案。
所有的写操作以DB为准，只要到达缓存过期时间，则后面的读请求自然会从DB读取新值，然后回填缓存。

结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加写请求耗时。

# 写完数据库后，再次删除缓存成功保证

上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。
需提供保障重试方案。

## 方案一
### 具体流程

1. 更新数据库数据
2. 缓存因为种种问题删除失败
3. 将需要删除的key发送至消息队列
4. 自己消费消息，获得需要删除的key
5. 继续重试删除操作，直到成功

然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二。
在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

## 方案二
### 具体流程

1. 更新数据库数据
2. 数据库会将操作信息写入binlog日志当中
3. 订阅程序提取出所需要的数据以及key
4. 另起一段非业务代码，获得该信息
5. 尝试删除缓存操作，发现删除失败
6. 将这些信息发送至消息队列
7. 重新从消息队列中获得该数据，重试操作。

以上方案都是在业务中经常会碰到的场景，可以依据业务场景的复杂和对数据一致性的要求来选择具体的方案。