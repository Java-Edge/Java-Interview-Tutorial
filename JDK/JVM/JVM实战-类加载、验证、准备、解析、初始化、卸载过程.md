# 0 使用类的准备工作

任何程序都需要加载到内存才能与CPU进行交流，同理, 字节码.class文件同样需要加载到内存中，才可以实例化类。
`ClassLoader`的使命就是提前加载.class 类文件到内存中，在加载类时，使用的是Parents Delegation Model(溯源委派加载模型)。

Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的加载、链接、初始化：
- Java 类加载过程
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LWJmZGRhYjUzMjk5ZTIyZTQucG5n)
## Load-加载
由类加载器执行。

读取类文件（通常在 classpath 所指定的路径中查找，但classpath非必须），查找字节码，从而产生二进制流，并转为特定数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等，然后创建对应类的java.lang.Class实例。

##  Link-链接
将已读入内存的类的二进制数据合并到 JVM 运行时环境。
包括验证、准备、解析三步：
- 验证
确保被加载类的正确性。验证类中的字节码，是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理
- 准备
为类的static字段分配内存，并设定初始默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局
- 解析
如果需要的话，将解析这个类创建的对其他类的所有引用，将常量池的符号引用转换成直接引用 。
## Init-初始化
执行类构造器<clinit> 方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值

 类加载是一个将.class字节码文件实例化成Class对象并进行相关初始化的过程。
在这个过程中，JVM会初始化继承树上还没有被初始化过的所有父类，并且会执行这个链路上所有未执行过的静态代码块、静态变量赋值语句等。
某些类在使用时，也可以按需由类加载器进行加载。

全小写的class是关键字，用来定义类
而首字母大写的Class,它是所有class的类
这句话理解起来有难度，类已经是现实世界中某种事物的抽象，为什么这个抽象还是另外一个类Class的对象?
示例代码如下:
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTM0MTk3NGNiNTllZTY4MmEucG5n)
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTdlYmNlYjI0NDVmYzA3MjUucG5n)
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTViZDgyODE1ODU4MDI0YWUucG5n)
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LWE4MmM0NzUyMThhYzQ5NzAucG5n)
 ● 第1处说明:
Class类下的`newInstance()`在JDK9中已经置为过时，使用`getDeclaredConstructor().newInstance()`的方式
着重说明一下new与newInstance的区别
- new是强类型校验，可以调用任何构造方法，在使用new操作的时候，这个类可以没有被加载过
- 而Class类下的newInstance是弱类型，只能调用无参构造方法
    - 如果没有默认构造方法，就拋出`InstantiationException`异常;
    - 如果此构造方法没有权限访问，则拋 `IllegalAccessException`异常

Java 通过类加载器把类的实现与类的定义进行解耦，所以是实现面向接口编程、依赖倒置的必然选择。

● 第2处说明:
可以使用类似的方式获取其他声明，如注解、方法等
![类的反射信息](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTdkNTRhODI2OTI5NDU4NzUucG5n)
   
● 第3处说明: private 成员在类外是否可以修改?
通过`setccessible(true)`,即可使用Class类的set方法修改其值
如果没有这一步,则抛出如下异常:
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTQ3YWNmNjU0ZWQyNzZjOTUucG5n)


- 参考 
[看完这篇JVM类加载器,再也不怕阿里面试官了!](https://javaedge.blog.csdn.net/article/details/105250625)

# 1 加载的定位
> “加载”是“类加载”(Class Loading)过程的第一步。
## 1.1 加载过程
JVM主要做如下事情：
- 通过类的全限定名（保证全局唯一）获取该类的二进制字节流(class文件)
在程序运行过程中，当要访问一个类时,若发现这个类尚未被加载，并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。
把类加载阶段的“通过类的全限定名来获取该类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成的好处在于，可自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强加载器的灵活性。
- 将这个字节流的静态存储结构转化为方法区的运行时数据结构
- 在内存中创建一个该类的`java.lang.Class`对象，作为方法区该类的各种数据的访问入口，所以所有类都可以调用 getClass 方法

程序在运行中所有对该类的访问都通过这个类对象,也就是这个Class对象是提供给外界访问该类的接口
## 1.2 加载源
JVM规范对于加载过程给予了较大的宽松度。一般二进制字节流都从已经编译好的本地class文件中读取，此外还可以从以下地方读取
- zip包
Jar、War、Ear等
- 其它文件生成 
由JSP文件中生成对应的Class类
- 数据库中
将二进制字节流存储至数据库中,然后在加载时从数据库中读取.有些中间件会这么做,用来实现代码在集群间分发
- 网络
从网络中获取二进制字节流，比如Applet
- 运行时动态计算生成
动态代理技术，用`PRoxyGenerator.generateProxyClass`为特定接口生成形式为"*$Proxy"的代理类的二进制字节流


## 1.3 类和数组加载过程的区别
数组也有类型,称为“数组类型”，如：
```java
String[] str = new String[10];
```
这个数组的数组类型是`Ljava.lang.String`，而String只是这个数组的元素类型。
当程序在运行过程中遇到new关键字创建一个数组时，由JVM直接创建数组类,再由类加载器创建数组中的元素类型。

而普通类的加载由类加载器创建。既可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成(即重写一个类加载器的loadClass()方法)
## 1.4 加载过程的注意点
- JVM规范并未给出类在方法区中存放的数据结构 
类完成加载后,二进制字节流就以特定的数据结构存储在方法区中,但存储的数据结构是由虚拟机自己定义的,虚拟机规范并没有指定
- JVM规范并没有指定Class对象存放的位置 
在二进制字节流以特定格式存储在方法区后,JVM会创建一个java.lang.Class类的对象,作为本类的外部访问接口
既然是对象就应该存放在Java堆中,不过JVM规范并没有给出限制,不同的虚拟机根据自己的需求存放这个对象
HotSpot将Class对象存放在方法区.
- 加载阶段和链接阶段是交叉的 
类加载的过程中每个步骤的开始顺序都有严格限制,但每个步骤的结束顺序没有限制.也就是说,类加载过程中,必须按照如下顺序开始: 
>加载 -> 链接 -> 初始化

但结束顺序无所谓,因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉 
# 2 验证
验证阶段比较耗时,它非常重要但不一定必要(因为对程序运行期没有影响),如果所运行的代码已经被反复使用和验证过,那么可以使用`-Xverify:none`参数关闭,以缩短类加载时间
## 2.1 验证的目的
保证二进制字节流中的信息符合虚拟机规范,并没有安全问题
## 2.2 验证的必要性
虽然Java语言是一门安全的语言,它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行.也就是说,Java语言的安全性是通过编译器来保证的.

但是我们知道,编译器和虚拟机是两个独立的东西,虚拟机只认二进制字节流,它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。

通过上文可知，虚拟机规范中没有限制二进制字节流的来源，在字节码层面上,上述Java代码无法做到的都是可以实现的,至少语义上是可以表达出来的,为了防止字节流中有安全问题，需要验证！
## 2.3 验证的过程
- 文件格式验证 
验证字节流是否符合Class文件格式的规范,并且能被当前的虚拟机处理.
本验证阶段是基于二进制字节流进行的,只有`通过本阶段验证,才被允许存到方法区`
后面的三个验证阶段都是基于方法区的存储结构进行,不会再直接操作字节流.

> 通过上文可知，加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区
> 而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区
> 也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作
这个过程印证了：加载和验证是交叉进行的

- 元数据验证 
对字节码描述的信息进行语义分析，确保符合Java语法规范。
- 字节码验证 
验证过程的最复杂的阶段。 本阶段对数据流和控制流（主要为方法体）进行语义分析。字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全。
- 符号引用验证 
发生在JVM将符号引用转化为直接引用的时候，这个转化动作发生在解析阶段,对类自身以外的信息进行匹配校验,确保解析能正常执行.
# 3 准备
完成两件事情
- 为已在方法区中的类的静态成员变量分配内存 
- 为静态成员变量设置初始值 
初始值为0、false、null等
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzQ2ODU5NjgtZjYyYTU2YzAzNGM1MTgyMC5qcGc)
```
public static final int value = 123;
```
准备阶段后 a 的值为 0，而不是 123，要在初始化之后才变为 123,但若被final修饰的常量如果有初始值,那么在编译阶段就会将初始值存入constantValue属性中,在准备阶段就将constantValue的值赋给该字段(此处将value赋为123).
# 4 解析
把常量池中的**符号引用**转换成**直接引用**的过程。包括：
- 符号引用
以一组无歧义的符号来描述所引用的目标，与虚拟机的实现无关。
- 直接引用
直接指向目标的指针、相对偏移量、或是能间接定位到目标的句柄，是和虚拟机实现相关的。

主要针对：类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符。

# 5 初始化
真正开始执行类中定义的Java程序代码(或说是字节码)，类的初始化就是为类的静态变量赋初始值，初始化阶段就是执行类构造器`<clinit>`的过程。

- 如果类还没有加载和连接，就先加载和连接
- 如果类存在父类，且父类没有初始化，就先初始化父类
- 如果类中存在初始化语句，就依次执行这些初始化语句
- 如果是接口
	- 初始化一个类时，并不会先初始化它实现的接口
	- 初始化一个接口时，并不会初始化它的父接口
只有当程序首次使用接口里面的变量或者是调用接口方法的时候，才会导致接口初始化
- 调用Classloader类的loadClass方法来装载一个类，并不会初始化这个类，不属于对类的主动使用


clinit()方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。
在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。

## 类的初始化时机
Java程序对类的使用方式分为：
- 主动使用
- 被动使用

JVM必须在每个类或接口“首次主动使用”时才初始化它们，被动使用类不会导致类的初始化。主动使用的场景：
- **创建类实例**
- 访问某个类或接口的**静态变量**
如果是 final 常量，而常量在编译阶段就会在常量池，没有引用到定义该常量的类，因此不会触发定义该常量类的初始化
- 调用类的**静态方法**
- **反射**某个类
- 初始化某个类的子类，而父类还没有初始化
- JVM启动的时候运行的主类（等于第三条）
- 定义了 default 方法的接口，当接口实现类初始化时

 
## 初始化过程的注意点
- clinit()方法是IDE自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的,IDE收集的顺序是由语句在源文件中出现的顺序所决定的.
- 静态代码块只能访问到出现在静态代码块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问.
```java
public class Test {
    static {
        i=0;
        System.out.println(i); //编译失败:"非法向前引用"
    }
    static int i = 1;
}
```
- 实例构造器init()需要显式调用父类构造器，而类的clinit()无需调用父类的类构造器，JVM会确保子类的clinit()方法执行前已执行完毕父类的clinit()方法。
因此在JVM中第一个被执行的clinit()方法的类肯定是java.lang.Object.
- 如果一个类/接口无static代码块，也无 static成员变量的赋值操作，则编译器不会为此类生成clinit()方法
- 接口也需要通过clinit()方法为接口中定义的static成员变量显示初始化。
- 接口中不能使用静态代码块,但仍然有变量初始化的赋值操作,因此接口与类一样都会生成clinit()方法.不同的是,执行接口的clinit()方法不需要先执行父接口的clinit()方法.只有当父接口中的静态成员变量被使用到时才会执行父接口的clinit()方法.
- 虚拟机会保证在多线程环境中一个类的clinit()方法别正确地加锁,同步.当多条线程同时去初始化一个类时，只会有一个线程去执行该类的clinit()方法,其它线程都被阻塞等待,直到活动线程执行clinit()方法完毕.

> 其他线程虽会被阻塞，只要有一个clinit()方法执行完，其它线程唤醒后不会再进入clinit()方法。同一个类加载器下，一个类型只会初始化一次。

# 6 类的卸载
当代表一个类的Class对象不再被引用，那么Class对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。
Jvm自带的类加载器装载的类,是不会卸载的，由用户自定义的类加载器加载的类是可以卸载的。

参考
- 《码到成功》
- 《深入理解Java虚拟机第三版》