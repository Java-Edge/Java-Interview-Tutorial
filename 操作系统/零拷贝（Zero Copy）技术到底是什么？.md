rabbitmq 这么高吞吐量都是因为零拷贝技术，本文以 kafka 为例讲解。

消息从发送到落地保存，broker 维护的消息日志本身就是文件目录，每个文件都是二进制保存，生产者和消费者使用相同格式来处理。

Con获取消息时，服务器先从硬盘读取数据到内存，然后将内存中数据通过 socket 发给Con。

Linux的零拷贝技术：当数据在磁盘和网络之间传输时，避免昂贵的内核态数据拷贝，从而实现快速数据传输。
Linux平台实现了这样的零拷贝机制，但Windows必须要到Java 8的60更新版本才能“享受”到。
![](https://img-blog.csdnimg.cn/img_convert/74e0931f6470ebdcadd5ed9fbd8897f2.png)
- os将数据从磁盘读入到内核空间的页缓存
- 应用程序将数据从内核空间读入到用户空间缓存
- 应用程序将数据写回到内核空间到 socket 缓存
- os将数据从 socket 缓冲区复制到网卡缓冲区，以便将数据经网络发出

该过程涉及：
- 4 次上下文切换
- 4 次数据复制
有两次复制操作是 CPU 完成的。但该过程中，数据完全无变化，仅是从磁盘复制到网卡缓冲区。

而通过“零拷贝”技术，能去掉这些没必要的数据复制操作， 也减少了上下文切换次数。
现代的 unix 操作系统提供一个优化的代码路径，将数据从页缓存传输到 socket; 
在 Linux 中，是通过 sendfile 系统调用完成的。Java 提供了访问这个系统调用的方法:**FileChannel.transferTo** API
![](https://img-blog.csdnimg.cn/img_convert/633eeab1746ea396f2d67bab8fb3fbc2.png)
使用 sendfile，只需一次拷贝，允许os将数据直接从页缓存发送到网络。
所以在这个优化的路径中， 只有最后一步：将数据拷贝到网卡缓存中是必须的。