软件开发就是在解决问题。
- 那问题一般如何解决？
最常见的解决思路是分而治之。但如何分解、组合，就是软件设计中考虑的问题。

然而，软件设计环节的大部分人都聚焦如何组合，忽略了第一步：分解。
“分解？不就是把一个大系统拆成子系统，再把子系统拆成模块，一层层拆下去呗。”
这种程度分解远远不够，因为粒度太大了，就会导致不同东西混淆一起。听不懂？那就看个案例吧。
# 技术和业务耦合
某清结算系统，一开始觉得是个业务规则比较多的系统，偶尔出点故障，也情有可原。
但分析系统故障报告后，发现这个系统设计得极其复杂。
有一处：上游系统以推送方式向这个系统发消息。在原本的实现中，开发人员发现这个过程可能会丢消息，于是设计了一个补偿机制：
因为推送过来的数据是之前由这个系统发出去的，它本身有这些数据的初始信息，于是，开发人员就在DB增加一个状态，记录消息返回的情况。
一旦发现丢消息，该系统就会访问上游接口，将丢失的数据请求回来。

就是这补偿机制设计，带来了后续问题。比如，当系统业务量增加时，DB访问压力本身很大，但在这时，丢数据概率也增加了，用于补偿的线程也会频繁访问DB，因为它要找出丢失数据，还要把请求回来的数据写回DB。

即一旦业务量上升，本来就吃力的系统，负担更重，系统卡顿在所难免。

补偿机制的设计有问题，在于上游系统向下游推消息，应该是个通信层面问题。而在原有的设计中，因为那个状态的添加，这个问题被带到业务层面。
典型的分解没有做好，分解粒度太大。开发只考虑业务功能，忽视其他维度。技术和业务混在一起。

> 那到底怎么设计呢？

既然是否丢消息是通信层面的事，争取在通信层解决。
当时的解决方案是，选择吞吐量更大的MQ。在未来可见的业务量下，消息都不会丢。通信层面的问题在通信层面解决了，业务层面也就不会受到影响了。改造后，系统的稳定性果然得到大幅提升。

- 这样上游系统的补偿接口，现在也不需要了，上游系统得到简化
- 这个系统里那个表示状态的字段，其实还被用在了业务处理中，也引发过其他问题，现在它只用在业务处理中，角色单一了，相关问题也就少了

有人见怪了，觉得补偿机制还是要的吧，就算换吞吐量大的消息队列，丢失消息还是有可能出现的，只是几率小很多。只是之前的补偿机制设计得不合理？
若分析是不是丢消息，就要看它何时会丢消息。之前的业务丢消息是因为MQ处理不过来，而换了吞吐更好的MQ就不存在该问题了。
其实，真正需要的是可靠的信息传送通道，至于是不是MQ不重要。若怕丢消息，可在生产端重试，在消费者端做幂等。补偿是一个能把场景弄复杂的做法，不推荐。

常见的还有要区分技术异常和业务异常的。技术层面的异常信息不应该暴露给上层的业务人员。典型的例子就是大型网站的错误页面，而不是直接把后台的npe堆栈信息抛给用户。

技术与业务的分割线太模糊。代码的重构优化会点，但是分离关注点就涉及到具体的业务了，具体业务的划分与分离就又迷茫了。

简单区分：
- 业务人员能理解的就是业务
比如，订单
- 业务人员不理解的就是技术
比如，多线程

软件设计都期望将粒度分解越小越好，但又嫌分解太小过于麻烦。就像很多人希望别人写好文档，自己却不写。

业务代码和技术实现往往被混写在一起，都是因为分离不够！
# 分离关注点
看来分解粒度太大是不太好哦。那到底该如何考虑分解？

传统上，我们习惯的分解问题的方式是树型。
比如，按功能分解，可分为：功能1、2、3等，然后，每个功能再分成功能1.1、功能1.2、功能2.1、功能3.1等。

只从业务上看，似乎没问题。但要实现一个真实的系统，不仅要考虑功能性需求，还要考虑非功能性需求。
比如数据不能丢失、有的系统还要求处理速度快。

这与业务不是同维度，设计时要能发现这些非功能性需求。
分解问题时候，会有很多维度，每个都代表着一个关注点，这就是设计中一个常见的说法，“分离关注点（Separation of concerns）”。

可以分离的关注点很多，最常见的就是把业务处理和技术实现两个关注点混杂。

> 如果现在业务的处理性能跟不上，你有什么办法解决吗？

多线程！的确是一种解决方案。但若不限制地去修改这段代码成多线程，则会引入多线程相关问题，比如，各种资源竞争、数据同步，稍有不慎，更多 bug。

**写好业务规则**和**正确地处理多线程**，这是两个不同关注点，应该分离业务代码和多线程代码。

业务程序员基本都不该写多线程程序，应由专门程序员把并发处理封装成框架，提供给大家使用，写业务代码即可。

> Kent Beck 曾曰：我不准备在这本书里讲高并发问题，我的做法是把高并发问题从我的程序里移出去

把业务处理和技术实现混在一起的问题还有很多。
比如经常问怎么处理分布式事务，怎么做分库分表等。更该问的是，业务需要分布式事务吗？我是不是业务划分不清楚，才造成DB压力？

程序员最常犯的错误就是认为所有问题都是技术问题，总试图用技术解决所有问题。任何试图用技术去解决其他关注点的问题，只是越挣扎，陷得越深。

另外容易产生混淆的关注点是
# 不同的数据变动方向
做数据库访问用Spring Data JPA好，还是MyBatis好。Spring Data JPA简化了数据库访问，自动生成对应的SQL语句，而MyBatis则要自己手写SQL。

普通的增删改查用Spring Data JPA非常省事，但对于一些复杂场景，他会担心自动生成SQL的性能有问题，还是手写SQL优化来得直接。是不是挺纠结的？

为什么需要复杂查询？
你会说有一些统计报表需要。

那你发现了其中混淆关注点的地方？普通的增删改查需要经常改动数据库，而复杂查询的使用频率其实很低。

之所以出现工具选择的困难，是因为把两种数据使用频率不同的场景混在一起。如果将前台访问（处理增删改查）和后台访问（统计报表）分开，纠结也就不复存在。

不同的数据变动方向还有很多，比如：
- 动静分离，就是把变和不变的内容分开
- 读写分离，就是把读和写分开
- 前面提到的高频和低频，也可以分解开；
……

不同的数据变动方向，就是一个潜在的、可以分离的关注点。

分离关注点，不只适用于宏观的层面。
在微观的代码层面，你用同样的思维方式，也可以帮助你识别出一些混在一起的代码。比如，很多程序员很喜欢写setter，但你真的有那么多要改变的东西吗？实际上可能就是封装没做好而已。

分离关注点之所以重要，有两方面原因：
- 不同的关注点混在一起会带来一系列的问题，正如前面提到的各种问题
- 当分解得足够细小，你就会发现不同模块的共性，才有机会把同样的信息聚合在一起。这会为软件设计的后续过程，也就是组合，做好准备。

# CQRS（Command Query Responsibility Segregation）
命令与查询职责分离，其分离了增删改与查询这两个关注点。
- 静态上，拆分了这两块代码。使各自可以采用不同技术栈，做针对性的调优。动态上，切分了流量，能够更灵活的做资源分配。

- 查询服务的实现
可以走从库，这有利于降低主库压力，也可以做到水平扩展。但需要注意数据延迟问题。在异步同步和同步多写上要做好权衡。
也可都走主库，这时候查询服务最好增加缓存层，降低主库压力，而增删改服务要做好缓存的级联操作，以保证缓存时效
当然也可以走非关系型数据库，搜索引擎类的es,solr，分布式存储的tidb等等，按需选择。

通常增删改会涉及到很多domain knowledge. 平时更多的操作其实是查询，不需要通过从持久化生成domain model到内存中再返回。
# FAQ
## 订单系统
- 先下单写到DB
- 然后发送消息给MQ

这两步没法放到一个事务。 如果用本地消息表：
- order写DB
- 然后在写本地消息表

这两步就能放到一个事务了，保证肯定成功。
然后再有线程读取本地消息表，MQ发消息，如果成功，更改本地消息表状态 。
### 分析
下单入库和发消息给下游确实是两个动作，但这两个动作的顺序一定是这样？一定要在一个线程完成吗？可不可以先发消息呢？
比如，把消息发给下游后，有个下游接收到消息后，再把消息入库。
如果这样，发消息，由MQ保证消息不丢，下游入库，又可保证订单持久化。这种设计下，其实并不需要事务，也就不必为事务纠结了。

发现大家在工作中往往不做分离，分析需求的时候把方案揉在一起。可以怎样去练习做分离呢？
有一种从小事练起的方法，就是写代码时，把自己写的函数行数限定在一定的规模之下，比如，10行。超过10行的代码，你就要去仔细想想是否是有东西混在了一起。
这种方法锻炼的就是找出不同关注点的思维习惯，一旦你具备了这种思维习惯，再去看大的设计，自然也会发现不同的关注点。

##  用户购买会员
目前设计了两张表：
- 存储用户购买会员的所有记录
- 存当前的会员信息 (主要是开始、结束时间，但没有会员等级之类)
设计这张表是为了SQL关联查询方便，不用再判断是否过期

但有个问题：我要用定时器一直扫这表，等会员过期了，就得删除对应记录。
这么做的问题在哪？ 更好的解决方式应该是什么？如果做到更细维度的拆分？

首先，没有把业务和实现分清。
业务是实现一个会员系统，涉及会员购买，主要是会员时间要延长，还会涉及会员资格的判断，即当前用户是否是会员。

基于这些内容判断，可以有不同实现。根据当前实现，可以这样：
购买会员；
- 若会员信息不存在，则添加会员信息
- 会员信息存在，则修改会员结束时间

会员资格判别，根据用户 ID 和当前时间是否在时间范围内查询：
- 记录存在，则是会员
- 否则不是

因此可考虑：
- 购买会员时，可产生会员购买记录，此记录仅供后续查询用
- 只有当会员信息表过大时，才考虑是否需要删除

在这个实现中：
- 把 购买 和 会员信息 分开
- 把 会员信息是否生效 与 记录是否删除 分开
# 总结
软件设计第一步：分解。

大多数系统的设计做得不够好，问题常常出现在分解这步就没做好。常见的分解问题就是分解的粒度太大，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫分离关注点。

分离关注点很重要，一方面，不同的关注点混在一起会带来许多问题；另一方面，分离关注点有助于我们发现不同模块的共性，更好地进行设计。分离关注点，是我们在做设计的时候，需要时时绷起的一根弦。

- 分离关注点是一种意识，在设计中要意识到需要分离关注点。一旦自己在做设计时，出现纠结或者是觉得设计有些复杂，首先需要想想，是不是因为把不同的关注点混在了一起。这种意识是需要训练的，让自己从无意识中摆脱出来。
一种可以考虑的做法是，把它与一些实践结合起来，比如，在设计评审的DoD中，增加一条“是否考虑了分离关注点”。
- 分离关注点也要从小事开始练习
比如，可以从编写小函数开始。给自己设定了一个目标，函数代码小于10行。每次写完代码，就可以对代码进行调整。超过10行代码的函数，问问自己，是不是有混在一起的内容？
	- 如果有循环，循环里面的部分就是对单个元素的处理，可以提取到一个函数里
	- 如果有if...else，每种情况都可以单独放到一个函数里
	- 如果有多个 if...else，要问问自己是不是缺少了一些模型，是不是可以用多态解决
...
如果经过练习，函数都能写短，那就可以开始做类的练习。把每个类写小，以此类推，逐步训练。《重构》里《代码的坏味道》可以成为我们改进的参考点。

只有在日常开发的过程中不断练习，才能成为我们的下意识反应。

**分离关注点，发现的关注点越多越好，粒度越小越好。**
![](https://img-blog.csdnimg.cn/99612de7ae6e46e2a8d0f1646a9d513a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmF2YUVkZ2Uu,size_20,color_FFFFFF,t_70,g_se,x_16)